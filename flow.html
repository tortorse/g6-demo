<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flow Editor</title>
  <style>
    html {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    * {
      box-sizing: border-box;
    }

    body {
      background: #F0F2F5;
      margin: 0;
      height: 100%;
      overflow: hidden;
      font-size: 14px;
      padding: 24px;
    }

    .editor {
      background: #fff;
      height: 100%;
    }

    .toolbar {
      height: 44px;
      background: #FAFAFA;
      box-shadow: 0 -1px 0 inset rgba(0, 0, 0, 0.08);
      padding: 0 8px;
      display: flex;
      align-items: center;
    }

    .toolbar ul {
      margin: 0;
      padding: 0;
      display: flex;
      align-items: center;
    }

    .toolbar ul li.item {
      list-style: none;
      display: inline-block;
      width: 24px;
      text-align: center;
      line-height: 24px;
      margin: 0 4px;
      transition: all ease-in-out 0.3s;
      border: 1px solid rgba(0, 0, 0, 0);
    }

    .toolbar ul li.item:hover {
      border: 1px solid rgba(0, 0, 0, .05)
    }

    .toolbar ul li.divider {
      width: 1px;
      height: 16px;
      background: rgba(0, 0, 0, .05);
      display: inline-block;
      margin: 0 8px;
    }

    .toolbar ul li.item svg {
      fill: rgba(0, 0, 0, .65);
      width: 14px;
      transform: translateY(3px);
    }

    .toolbar ul li.disabled {
      cursor: not-allowed;
    }

    .toolbar ul li.disabled svg {
      fill: rgba(0, 0, 0, .25)
    }

    .container {
      display: flex;
      height: calc(100% - 44px);
    }

    .item-panel {
      width: 240px;
      box-shadow: -1px 0 0 inset rgba(0, 0, 0, 0.08);
      padding: 24px;
    }

    .items {
      margin: 0;
      padding: 0;
    }

    .items li.item {
      list-style: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 24px;
      cursor: pointer;
    }

    .items li.item:last-child {
      margin-bottom: 0;
    }

    .detail-panel {
      width: 240px;
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      padding: 10px 16px;
      background: #FAFAFA;
      box-shadow: 0 -1px 0 inset rgba(0, 0, 0, 0.08);
    }

    .property {
      flex: 1;
      padding: 16px;
    }

    .property .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }

    .property .row .label {
      text-align: right;
      margin-right: 8px;
      width: 33.3%;
    }

    .property .row .input {
      font-variant: tabular-nums;
      width: 66.6%;
      padding: 4px 11px;
      border: 1px solid #d9d9d9;
      border-radius: 2px;
      line-height: 1.5715;
      color: rgba(0, 0, 0, .85);
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }

    .property .row .input:focus {
      border-color: #40a9ff;
      outline: 0;
      box-shadow: 0 0 0 2px rgba(24, 144, 255, .2);
    }

    .property .row .input:hover {
      border-color: #40a9ff;
    }

    .property .row option {
      padding: 5px 12px;
    }

    .property .row .label::after {
      content: ':'
    }

    .canvas {
      flex: 1;
      box-shadow: -1px 0 0 inset rgba(0, 0, 0, 0.08);
      position: relative;
    }

    .context-menu-container {
      overflow: hidden;
      background: #fff;
      border-radius: 4px;
      box-shadow: 0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05);
    }

    .context-menu {
      margin: 0;
      padding: 0;
    }

    .context-menu li {
      list-style: none;
      color: rgba(0, 0, 0, .65);
      padding: 5px 12px;
    }

    .context-menu li.disabled {
      color: rgba(0, 0, 0, .25)
    }

    .context-menu li span {
      cursor: default;
    }

    .context-menu li span:not(:last-child) {
      margin-right: 8px;
    }

    .context-menu li:hover {
      background: #f5f5f5;
    }

    .context-menu li svg {
      width: 14px;
      fill: rgba(0, 0, 0, .65)
    }

    .context-menu li.disabled svg {
      fill: rgba(0, 0, 0, .25)
    }
  </style>
</head>

<body>
  <div class="editor">
    <div class="toolbar">
      <ul>
        <li class="item disabled" data-command="undo">
          <span role="img">
            <svg id="icon-undo" viewBox="0 0 1024 1024">
              <path
                d="M143.14 449.19q69.07-89.09 170.67-140.64Q415.41 257 537.52 256q183.18 4 315.81 114.11T1024 654.39q-58.06-107.11-161.66-170.17-103.6-63.06-232.73-65.06-107.1 1-196.69 45.54-89.58 44.55-152.65 121.62L407.4 713.45q7 7 7 17.01 0 10.01-7 17.02t-17.01 7.01H32.04q-14.01 0-23.02-9.01T0.01 722.46V364.11q0-10.01 7-17.02t17.02-7.01q10.01 0 17.02 7.01l102.1 102.1z">
              </path>
            </svg>
          </span>
        </li>
        <li class="item disabled" data-command="redo">
          <span role="img">
            <svg id="icon-redo" viewBox="0 0 1024 1024">
              <path
                d="M999.98 340.08q-10.01 0-17.02 7.01l-102.1 102.1q-69.07-89.09-170.67-140.64Q608.59 257 487.48 256q-184.18 4-316.81 114.11T0 654.39q58.06-107.11 161.66-170.17 103.6-63.06 232.73-65.06 107.1 1 197.19 45.54 90.09 44.55 152.15 121.62L616.6 713.45q-7 7-7 17.01 0 10.01 7 17.02t17.01 7.01h358.35q14.01 0 23.02-9.01t9.01-23.02V364.11q0-10.01-7-17.02t-17.01-7.01z">
              </path>
            </svg>
          </span>
        </li>
        <li class="divider"></li>
        <li class="item disabled" data-command="copy">
          <span role="img">
            <svg id="icon-copy" viewBox="0 0 1024 1024">
              <path
                d="M990.08 1017.64h-549.1q-10.6 0-18.55-8.48-7.95-8.48-9.01-19.08V373.13q1.06-10.6 10.07-18.55 9.01-7.95 23.85-9.01h373.13L1024 549.1v448.4q-5.3 5.3-14.31 12.19-9.01 6.89-19.61 7.95zM814.11 407.06v135.68H949.8L814.11 407.06zM949.8 610.58H746.27V407.06H474.9V949.8h474.9V610.58z m-610.59 67.85H67.84V67.84h271.37v203.53h271.37v-67.84L407.06 0H33.92Q18.02 0 9.01 8.48T0 27.56v684.79q0 10.6 8.48 18.55 8.48 7.95 19.08 9.01h311.65v-61.48z m67.85-610.59l135.68 135.69H407.06V67.84z">
              </path>
            </svg>
          </span>
        </li>
        <li class="item disabled" data-command="paste">
          <span role="img">
            <svg id="icon-paste" viewBox="0 0 1024 1024">
              <path
                d="M795.99 199.33h-75.02v-62.16h109.31q10.72 0 19.3 8.58 8.57 8.57 8.57 19.29v102.88h-62.16v-68.59zM240.87 898.05h-75.02V199.33h75.02v-62.16H131.56q-10.72 0-19.29 8.58-8.57 8.57-8.57 19.29v760.88q0 10.71 8.57 18.75t19.29 9.11h102.88l6.43-55.73z m411.52-623.7H309.46V137.17h68.58V62.16q1.07-26.8 18.22-43.94Q413.41 1.08 440.2 0.01h75.01q26.8 1.07 43.94 18.21 17.14 17.14 18.22 43.94v75.01h75.02v137.18zM515.21 62.16H440.2v75.01h75.01V62.16z m405.09 938.77V548.69L720.97 342.93H343.75q-16.08 0-25.19 8.57-9.11 8.57-9.11 19.3v623.7q0 10.72 8.57 18.76 8.57 8.04 19.29 9.11H886q15 4.28 24.11-2.68 9.11-6.97 10.18-18.76z m-68.58-438.31H714.54v-151.1l137.18 151.1z m6.43 411.52H371.61V411.52h280.78v212.19h205.76v350.43z">
              </path>
            </svg>
          </span>
        </li>
        <li class="item disabled" data-command="delete">
          <span role="img">
            <svg id="icon-delete" viewBox="0 0 1024 1024">
              <path
                d="M828.55 311.65q-17.81 0-30.05 11.13-12.25 11.13-14.47 28.94l-52.32 529.81h-95.72l16.7-461.91q0-14.47-10.02-25.05-10.02-10.57-25.05-11.13-15.02-0.56-25.6 8.91-10.58 9.46-10.58 25.04l-16.69 464.14H459.01l-15.58-465.25q-1.12-15.58-11.69-25.04-10.57-9.47-25.6-8.91-15.03 0.56-24.49 11.13-9.46 10.57-9.46 25.04l15.58 463.03h-94.6l-52.32-529.81q-2.22-17.81-14.47-28.94-12.24-11.13-30.05-11.13h-3.34q-15.58 2.23-25.04 13.36-9.46 11.13-8.35 26.71l60.1 599.93q3.34 31.17 25.6 51.21 22.26 20.03 53.43 21.14h426.3q31.16-1.11 53.42-21.14t26.72-51.21l58.99-603.27q0-15.58-10.57-26.15-10.58-10.58-25.05-10.58z m107.96-71.23l-7.79-61.22q-5.56-35.62-31.72-57.88-26.15-22.26-61.77-23.37h-170.3l-3.34-32.28q-2.22-28.94-22.25-46.75Q619.3 1.11 590.36 0H433.42Q404.48 1.11 385 18.92q-19.48 17.81-22.82 46.75l-2.22 32.28H188.55q-35.62 1.11-61.22 23.37T96.17 179.2l-8.91 63.44q0 7.79 5.01 12.8 5.01 5.01 12.8 5.01h816.98q6.67-1.11 11.13-6.68 4.46-5.56 3.34-13.35zM422.29 97.95l2.22-27.83q1.12-6.68 8.91-7.79h158.05q6.68 1.11 8.91 7.79l1.11 27.83h-179.2z">
              </path>
            </svg>
          </span>
        </li>
        <li class="divider"></li>
        <li class="item" data-command="zoom-in">
          <span role="img">
            <svg id="icon-zoom-in" viewBox="0 0 1024 1024">
              <path
                d="M636.36 411.93q0 17.86-10.12 27.98-10.12 10.12-27.98 10.12H483.97v114.3q0 17.85-10.12 27.97-10.12 10.12-27.98 10.12t-27.98-10.12q-10.12-10.12-10.12-27.97v-114.3H293.48q-17.86 0-27.98-10.12-10.12-10.12-10.12-27.97 0-17.86 10.12-27.98 10.12-10.12 27.98-10.12h114.29v-114.3q0-17.86 10.12-27.98 10.12-10.12 27.98-10.12t27.98 10.12q10.12 10.12 10.12 27.98v114.3h114.29q17.86 0 27.98 10.12 10.12 10.12 10.12 27.97z m342.88 602.43q-17.86 10.71-36.91 9.52-19.05-1.19-32.14-17.86L689.93 754.81q-52.38 40.48-113.7 61.91-61.31 21.43-130.36 21.43-176.2-4.76-295.25-123.81Q31.56 595.28 26.79 419.08q4.77-176.21 123.83-295.26Q269.68 4.77 445.87 0.01q176.2 4.76 295.25 123.81 119.05 119.06 123.83 295.26 0 80.95-26.2 149.41T766.12 694.1l220.25 258.35q11.91 7.14 10.72 25-1.19 17.86-17.86 36.91zM445.87 754.81q146.44-3.57 242.87-100 96.44-96.44 100.01-242.88-3.57-146.44-100.01-242.88-96.43-96.44-242.87-100.01-146.44 3.57-242.88 100.01-96.44 96.44-100.01 242.88 3.57 146.44 100.01 242.88 96.44 96.43 242.88 100z">
              </path>
            </svg>
          </span>
        </li>
        <li class="item" data-command="zoom-out">
          <span role="img">
            <svg id="icon-zoom-out" viewBox="0 0 1024 1024">
              <path
                d="M636.36 411.93q0 17.86-10.12 27.98-10.12 10.12-27.98 10.12H293.48q-17.86 0-27.98-10.12-10.12-10.12-10.12-27.97 0-17.86 10.12-27.98 10.12-10.12 27.98-10.12h304.78q17.86 0 27.98 10.12 10.12 10.12 10.12 27.97z m342.88 602.43q-17.86 10.71-36.91 9.52-19.05-1.19-32.14-17.86L689.93 754.81q-52.38 40.48-113.7 61.91-61.31 21.43-130.36 21.43-176.2-4.76-295.25-123.81Q31.56 595.28 26.79 419.08q4.77-176.21 123.83-295.26Q269.68 4.77 445.87 0.01q176.2 4.76 295.25 123.81 119.05 119.06 123.83 295.26 0 80.95-26.2 149.41T766.12 694.1l220.25 258.35q11.91 7.14 10.72 25-1.19 17.86-17.86 36.91zM445.87 754.81q146.44-3.57 242.87-100 96.44-96.44 100.01-242.88-3.57-146.44-100.01-242.88-96.43-96.44-242.87-100.01-146.44 3.57-242.88 100.01-96.44 96.44-100.01 242.88 3.57 146.44 100.01 242.88 96.44 96.43 242.88 100z">
              </path>
            </svg>
          </span>
        </li>
        <li class="item" data-command="fit-map">
          <span role="img">
            <svg id="icon-fit-map" viewBox="0 0 1024 1024">
              <path
                d="M708.913 275.697V39.39q0-18.46 10.47-28.92T748.303 0.01q18.46 0 28.92 10.46t10.46 28.92v196.928H984.61q18.46 0 28.92 10.46t10.46 28.92q0 18.46-10.46 28.929-10.46 10.46-28.92 10.46H748.303q-6.16 0-11.69-1.23-5.53-1.23-11.7-6.16h-8.61q0-12.31-3.69-19.07-3.7-6.76-3.7-12.93zM275.687 0.01q-18.46 0-28.92 10.46t-10.46 28.92v196.928H39.38q-18.46 0-28.92 10.46T0 275.698q0 18.46 10.46 28.929 10.46 10.46 28.92 10.46h236.307q6.16 0 11.69-1.23 5.54-1.23 11.69-6.16h8.61q4.93-6.15 6.16-12.31 1.23-6.15 1.23-12.31V46.77q0-23.39-10.46-35.08Q294.137 0 275.677 0zM984.61 708.923H748.303q-6.16 0-11.69 1.23-5.53 1.23-11.7 6.16h-8.61q-4.93 6.15-6.16 12.31-1.23 6.15-1.23 12.3V977.23q0 17.23 10.47 27.69t28.92 10.46q18.46 0 28.92-10.46t10.46-27.69V787.692H984.61q18.46 0 28.92-10.46t10.46-28.92q0-18.46-10.46-28.919-10.46-10.47-28.92-10.47z m-676.923 16q-12.31-12.3 0 0-12.31-6.15-19.07-11.07-6.76-4.93-12.93-4.93H39.38q-18.46 0-28.92 10.47T0 748.313q0 18.46 10.46 28.92t28.92 10.46h196.928V984.62q0 18.46 10.46 28.92t28.92 10.46q18.46 0 28.929-10.46 10.46-10.46 10.46-28.92V748.313q0-6.16-3.69-11.69-3.69-5.53-3.69-11.7z m204.308-370.456q-66.46 1.23-111.379 46.16-44.93 44.929-46.16 111.378 1.23 66.46 46.16 111.379t111.379 46.15q66.46-1.23 111.379-46.15t46.15-111.379q-1.23-66.46-46.15-111.379-44.92-44.93-111.379-46.16z">
              </path>
            </svg>
          </span>
        </li>
        <li class="item" data-command="actual-size">
          <span role="img">
            <svg id="icon-actual-size" viewBox="0 0 1024 1024">
              <path
                d="M128 0h85.33v1024H128V0z m682.67 0H896v1024h-85.33V0zM469.33 256h85.34v85.33h-85.34V256z m0 341.33h85.34v85.34h-85.34v-85.34z">
              </path>
            </svg>
          </span>
        </li>
        <li class="divider"></li>
        <li class="item disabled" data-command="to-back">
          <span role="img">
            <svg id="icon-to-back" viewBox="0 0 1024 1024">
              <path
                d="M720.86 373.26l-94.8-12.84L739.62 259.7q4.94-4.93 7.9-12.83t-1.97-12.84q0-8.89-7.41-13.83-7.41-4.93-17.28-4.93l-94.8-12.84 113.56-100.72q4.94-4.94 7.9-12.84 2.96-7.9-1.97-12.84 0-8.88-7.41-13.82-7.41-4.94-17.28-4.94L360.43 0q-4.93 0-9.87 0.98-4.94 0.98-8.89 5.92L25.68 234.02q-4.93 4.94-8.88 12.84-3.95 7.9-3.95 12.83 0 8.89 6.91 13.82 6.91 4.94 11.85 4.94l107.63 25.68-120.47 87.88q-4.94 4.94-8.4 12.84-3.46 7.9-3.46 12.83 0 4.94 6.42 11.36 6.42 6.42 12.34 7.41l106.65 25.67-119.48 87.89q-4.94 4.93-8.89 12.83T0 575.68q0.99 8.89 7.41 13.83 6.42 4.93 11.36 4.93l379.19 88.87q4.94 0 12.83-0.99 7.9-0.99 12.84-5.93l297.23-265.63q4.94-4.93 7.4-12.33 2.47-7.41-1.49-12.35 8.89-4.94 6.42-8.89-2.47-3.95-12.34-3.95zM360.43 51.35L657.66 94.8 410.79 310.06l-310.06-76.03 259.7-182.68zM215.28 315.99l201.44 51.35q5.92 0 13.33-0.99t12.34-5.93l132.32-119.48 82.95 11.85-246.87 215.27-310.06-76.04 114.55-76.03zM929.21 449.3h94.8L884.78 626.05 745.55 449.3h94.79v-12.84q0-71.1-21.73-132.81-21.73-61.71-60.24-114.05 77.02 39.5 123.44 108.62 46.41 69.13 47.39 151.09z">
              </path>
            </svg>
          </span>
        </li>
        <li class="item disabled" data-command="to-front">
          <span role="img">
            <svg id="icon-to-front" viewBox="0 0 1024 1024">
              <path
                d="M758.38 392.02q-4.94-8.88-10.37-13.82-5.43-4.94-15.3-4.94l-100.72-12.84L745.55 259.7q4.93-4.93 7.89-12.83 2.97-7.9-0.98-12.84-4.94-8.89-10.87-13.83-5.93-4.93-14.82-4.93l-100.72-12.84 113.56-100.72q4.94-4.94 7.9-12.84 2.96-7.9-1.97-12.84-3.95-8.88-9.88-13.82-5.92-4.94-14.81-4.94L353.51 0q-4.94 0-12.35 0.98-7.4 0.98-12.33 5.92L12.84 234.02q-4.94 4.94-8.89 12.84Q0 254.76 0 259.69q0.99 8.89 7.41 13.82 6.42 4.94 11.36 4.94l113.56 25.68-119.48 87.88q-4.94 4.94-8.89 12.84-3.95 7.9-3.95 12.84 0.99 8.88 7.41 13.82 6.42 4.94 11.36 4.94l113.56 25.67-119.48 87.89q-4.94 4.93-8.89 12.83T0.02 575.68q0.99 8.89 7.41 13.83 6.42 4.93 11.36 4.93l386.1 94.8q4.94 0 12.35-0.99 7.4-0.99 12.34-4.94l303.15-265.62q18.76-4.94 22.71-12.84 3.95-7.9 2.96-12.84z m-543.1-76.03l201.44 51.35q5.92 0 13.33-0.99t12.34-5.93l132.32-119.48 82.95 11.85-246.87 215.27-315.98-76.04 120.47-76.03z m201.44 315.99l-315.99-75.05 107.63-76.04 202.43 50.37q4.94 0 12.35-0.99 7.4-0.99 13.33-4.94l132.32-120.47 81.96 12.84-234.03 214.28z m468.06-442.39l139.23 177.75h-94.8q-5.92 85.91-53.32 153.06-47.4 67.14-123.43 105.65Q789.98 573.72 811.7 512q21.73-61.72 22.72-132.81v-11.85h-94.8l145.16-177.75z">
              </path>
            </svg>
          </span>
        </li>
        <li class="divider"></li>
        <li class="item" data-command="brush-select">
          <span role="img">
            <svg id="icon-brush-select" viewBox="0 0 1024 1024">
              <path
                d="M0 136.53h68.27v68.27H0v-68.27z m0 136.54h68.27v68.26H0v-68.26zM0 409.6h68.27v68.27H0V409.6z m0 136.53h68.27v68.27H0v-68.27z m0 136.54h68.27v68.26H0v-68.26z m0-614.4V0h68.27v68.27H0z m136.53 0V0h68.27v68.27h-68.27z m136.54 0V0h68.26v68.27h-68.26z m136.53 0V0h68.27v68.27H409.6z m136.53 0V0h68.27v68.27h-68.27z m136.54 0V0h68.26v68.27h-68.26zM819.2 0h68.27v68.27H819.2V0z m0 136.53h68.27v68.27H819.2v-68.27z m0 136.54h68.27v68.26H819.2v-68.26z m0 136.53h68.27v68.27H819.2V409.6z m0 136.53h68.27v68.27H819.2v-68.27zM0 887.47V819.2h68.27v68.27H0z m136.53 0V819.2h68.27v68.27h-68.27z m136.54 0V819.2h68.26v68.27h-68.26z m136.53 0V819.2h68.27v68.27H409.6z m409.6-68.27V682.67h68.27V819.2H1024v68.27H887.47V1024H819.2V887.47H682.67V819.2H819.2z m-273.07 68.27V819.2h68.27v68.27h-68.27zM409.6 273.07v68.26h273.07v-68.26H409.6z m0-68.27h273.07q30.93 0 49.6 18.66 18.66 18.66 18.66 49.6v68.26q0 30.94-18.66 49.61-18.66 18.67-49.6 18.67H409.6q-30.93 0-49.6-18.67t-18.67-49.61v-68.26q0-30.94 18.67-49.6t49.6-18.66zM204.8 546.13v68.27h273.07v-68.27H204.8z m0-68.26h273.07q30.93 0 49.6 18.67 18.66 18.67 18.66 49.59v68.27q0 30.93-18.66 49.6-18.67 18.67-49.6 18.67H204.8q-30.93 0-49.6-18.67t-18.67-49.6v-68.27q0-30.93 18.67-49.59 18.67-18.67 49.6-18.67z">
              </path>
            </svg>
          </span>
        </li>
        <li class="item disabled" data-command="group">
          <span role="img">
            <svg id="icon-group" viewBox="0 0 1024 1024">
              <path
                d="M307.2 307.2v68.27h409.6V307.2H307.2z m0-68.27h409.6q30.93 0 49.6 18.67t18.67 49.6v68.27q0 30.93-18.67 49.59-18.67 18.67-49.6 18.67H307.2q-30.93 0-49.6-18.67t-18.67-49.59V307.2q0-30.93 18.67-49.6t49.6-18.67z m0 341.34v68.26h409.6v-68.26H307.2z m0-68.27h409.6q30.93 0 49.6 18.66 18.67 18.67 18.67 49.61v68.26q0 30.94-18.67 49.61-18.67 18.66-49.6 18.66H307.2q-30.93 0-49.6-18.66t-18.67-49.61v-68.26q0-30.94 18.67-49.61Q276.27 512 307.2 512zM102.4 204.8q-42.67-1.07-72-30.4T0 102.4q1.07-42.67 30.4-72t72-30.4q42.67 1.07 72 30.4t30.4 72q-1.07 42.67-30.4 72t-72 30.4z m0-68.27q16 0 25.06-9.06 9.06-9.06 9.06-25.06 0-16-9.06-25.06-9.06-9.07-25.06-9.07-16 0-25.06 9.07-9.07 9.06-9.07 25.06 0 16 9.07 25.06 9.06 9.06 25.06 9.06z m819.2 68.27q-42.67-1.07-72-30.4t-30.4-72q1.07-42.67 30.4-72t72-30.4q42.67 1.07 72 30.4t30.4 72q-1.07 42.67-30.4 72t-72 30.4z m0-68.27q16 0 25.06-9.06 9.07-9.06 9.07-25.06 0-16-9.07-25.06-9.06-9.07-25.06-9.07-16 0-25.06 9.07-9.07 9.06-9.07 25.06 0 16 9.07 25.06 9.06 9.06 25.06 9.06zM102.4 1024q-42.67-1.07-72-30.4T0 921.6q1.07-42.67 30.4-72t72-30.4q42.67 1.07 72 30.4t30.4 72q-1.07 42.67-30.4 72t-72 30.4z m0-68.27q16 0 25.06-9.07 9.06-9.06 9.06-25.06 0-16-9.06-25.06-9.06-9.07-25.06-9.07-16 0-25.06 9.07-9.07 9.06-9.07 25.06 0 16 9.07 25.06 9.06 9.07 25.06 9.07zM921.6 1024q-42.67-1.07-72-30.4t-30.4-72q1.07-42.67 30.4-72t72-30.4q42.67 1.07 72 30.4t30.4 72q-1.07 42.67-30.4 72t-72 30.4z m0-68.27q16 0 25.06-9.07 9.07-9.06 9.07-25.06 0-16-9.07-25.06-9.06-9.07-25.06-9.07-16 0-25.06 9.07-9.07 9.06-9.07 25.06 0 16 9.07 25.06 9.06 9.07 25.06 9.07z m-676.27-819.2V68.27h68.27v68.26h-68.27z m136.54 0V68.27h68.26v68.26h-68.26z m136.53 0V68.27h68.27v68.26H518.4z m136.53 0V68.27h68.27v68.26h-68.27zM68.27 273.07h68.26v68.26H68.27v-68.26z m0 136.53h68.26v68.27H68.27V409.6z m0 136.53h68.26v68.27H68.27v-68.27z m0 136.54h68.26v68.26H68.27v-68.26z m819.2-409.6h68.26v68.26h-68.26v-68.26z m0 136.53h68.26v68.27h-68.26V409.6z m0 136.53h68.26v68.27h-68.26v-68.27z m0 136.54h68.26v68.26h-68.26v-68.26zM245.33 955.73v-68.26h68.27v68.26h-68.27z m136.54 0v-68.26h68.26v68.26h-68.26z m136.53 0v-68.26h68.27v68.26H518.4z m136.53 0v-68.26h68.27v68.26h-68.27z">
              </path>
            </svg>
          </span>
        </li>
        <li class="item disabled" data-command="ungroup">
          <span role="img">
            <svg id="icon-ungroup" viewBox="0 0 1024 1024">
              <path
                d="M716.8 238.93H307.2q-30.93 0-49.6 18.67t-18.67 49.6v68.27q0 30.93 18.67 49.59 18.67 18.67 49.6 18.67h409.6q30.93 0 49.6-18.67t18.67-49.59V307.2q0-30.93-18.67-49.6t-49.6-18.67z m0 136.54H307.2V307.2h409.6v68.27z m0 136.53H307.2q-30.93 0-49.6 18.66-18.67 18.67-18.67 49.61v68.26q0 30.94 18.67 49.61 18.67 18.66 49.6 18.66h409.6q30.93 0 49.6-18.66t18.67-49.61v-68.26q0-30.94-18.67-49.61Q747.73 512 716.8 512z m0 136.53H307.2v-68.26h409.6v68.26zM102.4 0q-42.67 1.07-72 30.4T0 102.4q1.07 42.67 30.4 72t72 30.4q42.67-1.07 72-30.4t30.4-72q-1.07-42.67-30.4-72T102.4 0z m0 136.53q-16 0-25.06-9.06-9.07-9.06-9.07-25.06 0-16 9.07-25.06 9.06-9.07 25.06-9.07 16 0 25.06 9.07 9.06 9.06 9.06 25.06 0 16-9.06 25.06-9.06 9.06-25.06 9.06z m819.2 68.27q42.67-1.07 72-30.4t30.4-72q-1.07-42.67-30.4-72T921.6 0q-42.67 1.07-72 30.4t-30.4 72q1.07 42.67 30.4 72t72 30.4z m0-136.53q16 0 25.06 9.07 9.07 9.06 9.07 25.06 0 16-9.07 25.06-9.06 9.06-25.06 9.06-16 0-25.06-9.06-9.07-9.06-9.07-25.06 0-16 9.07-25.06 9.06-9.07 25.06-9.07z m-819.2 716.8q-42.67 1.06-72 30.39Q1.07 844.8 0 887.47q1.07 42.66 30.4 71.99 29.33 29.34 72 30.41 42.67-1.07 72-30.41 29.33-29.33 30.4-71.99-1.07-42.67-30.4-72.01-29.33-29.33-72-30.39z m0 136.53q-16 0-25.06-9.06-9.07-9.07-9.07-25.07t9.07-25.07q9.06-9.07 25.06-9.07 16 0 25.06 9.07 9.06 9.07 9.06 25.07t-9.06 25.07q-9.06 9.06-25.06 9.06z m819.2-136.53q-42.67 1.06-72 30.39-29.33 29.34-30.4 72.01 1.07 42.66 30.4 71.99 29.33 29.34 72 30.41 42.67-1.07 72-30.41 29.33-29.33 30.4-71.99-1.07-42.67-30.4-72.01-29.33-29.33-72-30.39z m0 136.53q-16 0-25.06-9.06-9.07-9.07-9.07-25.07t9.07-25.07q9.06-9.07 25.06-9.07 16 0 25.06 9.07 9.07 9.07 9.07 25.07t-9.07 25.07q-9.06 9.06-25.06 9.06z">
              </path>
            </svg>
          </span>
        </li>
      </ul>
    </div>
    <div class="container">
      <div class="item-panel">
        <ul class="items">
          <li class="item" data-type="start" data-width="72" data-height="72" data-label="Start">
            <img src="assets/flow/start.svg" alt="Start">
          </li>
          <li class="item" data-type="process" data-width="84" data-height="46" data-label="Process">
            <img src="assets/flow/process.svg" alt="Process">
          </li>
          <li class="item" data-type="decision" data-width="82" data-height="74" data-label="Decision">
            <img src="assets/flow/decision.svg" alt="Decision">
          </li>
          <li class="item" data-type="io" data-width="80" data-height="40" data-label="IO">
            <img src="assets/flow/io.svg" alt="IO">
          </li>
          <li class="item" data-type="terminal" data-width="80" data-height="48" data-label="Terminal">
            <img src="assets/flow/terminal.svg" alt="Terminal">
          </li>
        </ul>
      </div>
      <div class="canvas" id="canvas"></div>
      <div class="detail-panel">
        <div class="panel-header" id="property-title">Canvas</div>
        <div class="property"></div>
        <div class="panel-header">Minimap</div>
        <div class="minimap"></div>
      </div>
    </div>
  </div>
  <script src="https://gw.alipayobjects.com/os/lib/antv/g6/3.7.3/dist/g6.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.20/lodash.min.js"
    integrity="sha256-ur/YlHMU96MxHEsy3fHGszZHas7NzH4RQlD4tDVvFhw=" crossorigin="anonymous"></script>
  <script>
    const container = document.querySelector('.container')
    const items = document.querySelectorAll('.items .item')
    const img = new Image()
    img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
    items.forEach(item => {
      const { type, width, height, label } = item.dataset
      const addModel = {
        type,
        width,
        height,
        label
      }
      item.addEventListener('dragstart', e => {
        e.dataTransfer.setDragImage(img, 0, 0)
        graph.set('addNodeDragging', true)
        graph.set('addModel', addModel);
      })
      item.addEventListener('drag', e => {
        graph.emit('canvas:mousemove', e);
      })
      item.addEventListener('dragend', e => {
        graph.emit('canvas:mouseup', e);
        graph.set('addNodeDragging', false);
        graph.set('addModel', null);
      })
    })
    /**
    /* toolbar
    */
    const toolbar = document.querySelector('.toolbar > ul')
    let item
    toolbar.addEventListener('click', e => {
      if (e.target.matches('span')) {
        item = e.target.parentElement
      }
      if (e.target.matches('li')) {
        item = e.target
      }
      if (e.target.matches('svg')) {
        item = e.target.parentElement.parentElement
      }
      if (e.target.matches('path')) {
        item = e.target.parentElement.parentElement.parentElement
      }
      const { command } = item.dataset
      const currentZoom = graph.getZoom()
      switch (command) {
        case 'undo': {
          undo()
          break
        }
        case 'redo': {
          redo()
          break
        }
        case 'copy': {
          const nodes = graph.findAllByState('node', 'selected')
          if (nodes.length) {
            copy(nodes)
          }
          break
        }
        case 'paste': {
          paste()
          break
        }
        case 'delete': {
          const nodes = graph.findAllByState('node', 'selected')
          const edges = graph.findAllByState('edge', 'selected')
          if (nodes.length) {
            nodes.forEach(node => {
              graph.removeItem(node, true)
            })
            graph.emit('unselect', nodes)
          }
          if (edges.length) {
            edges.forEach(edge => {
              graph.removeItem(edge, true)
            })
            graph.emit('unselect', edges)
          }
          break
        }
        case 'zoom-in': {
          const ratioOut = 1 + 0.05 * 5
          if (ratioOut * currentZoom > 5) {
            return
          }
          graph.zoomTo(currentZoom * 1.1)
          break
        }
        case 'zoom-out': {
          const ratioIn = 1 - 0.05 * 5
          if (ratioIn * currentZoom < 0.3) {
            return
          }
          graph.zoomTo(currentZoom * 0.9)
          break
        }
        case 'fit-map': {
          graph.fitView(40)
          break
        }
        case 'actual-size': {
          graph.zoomTo(1)
          graph.fitCenter()
          break
        }
        case 'brush-select': {
          graph.setMode('brushSelect')
          graph.get('canvas').get('el').style.cursor = 'crosshair'
          break
        }
        default:
      }
    })

    /**
    /* context menu dom
    */
    const canvas = document.querySelector('#canvas')
    const menuContainer = document.createElement('div')
    menuContainer.setAttribute('style', 'position: absolute;display:none')
    menuContainer.className = 'context-menu-container'
    canvas.appendChild(menuContainer)

    const nodeStyle = {
      shadowOffsetX: 0,
      shadowOffsetY: 4,
      shadowBlur: 10,
      shadowColor: 'rgba(13, 26, 38, 0.1)',
      lineWidth: 1
    }
    const minimapContainer = document.querySelector('.minimap')
    const minimap = new G6.Minimap({
      size: [240, 200],
      container: minimapContainer
    })
    G6.registerNode('start', {
      drawShape(cfg, group) {
        const { width, height, x, y, id } = cfg
        const shape = group.addShape('circle', {
          attrs: {
            id,
            width,
            height,
            r: width / 2,
            stroke: '#FFC069',
            fill: '#FFF2E8',
            ...nodeStyle
          },
          name: 'startNodeShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 0
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            capture: true,
            draggable: true,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getFirst()
          value
            ? shape.attr(
              {
                fill: '#fdd492',
                stroke: '#fba746',
              }
            )
            : shape.attr(
              {
                fill: '#FFF2E8',
                stroke: '#FFC069',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('process', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('rect', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            x: - width / 2,
            y: - height / 2,
            stroke: '#1890FF',
            fill: '#E6F7FF',
            radius: 4,
            ...nodeStyle
          },
          name: 'processShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 1
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#92d4fd',
                stroke: '#55b2fe',
              }
            )
            : shape.attr(
              {
                fill: '#E6F7FF',
                stroke: '#1890FF',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('decision', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('polygon', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            points: [
              [0, - height / 2],
              [width / 2, 0],
              [0, height / 2],
              [-width / 2, 0]
            ],
            stroke: '#5CDBD3',
            fill: '#E6FFFB',
            ...nodeStyle
          },
          name: 'decisionShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 1
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#89e6dd',
                stroke: '#58d7d1',
              }
            )
            : shape.attr(
              {
                fill: '#E6FFFB',
                stroke: '#5CDBD3',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      }
    }, 'single-node')
    G6.registerNode('io', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('polygon', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            points: [
              [width / 4 - width / 2, - height / 2],
              [width - width / 2, - height / 2],
              [width - width / 4 - width / 2, height - height / 2],
              [- width / 2, height - height / 2]
            ],
            stroke: '#B4CC72',
            fill: '#F8FFE5',
            ...nodeStyle
          },
          name: 'ioShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 1
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#c8e08a',
                stroke: '#b5d45f',
              }
            )
            : shape.attr(
              {
                fill: '#F8FFE5',
                stroke: '#B4CC72',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('terminal', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('rect', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            x: - width / 2,
            y: - height / 2,
            stroke: '#B37FEB',
            fill: '#F9F0FF',
            radius: 24,
            ...nodeStyle
          },
          name: 'terminalShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 1
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#d3aff5',
                stroke: '#a26ee3'
              }
            )
            : shape.attr(
              {
                fill: '#F9F0FF',
                stroke: '#B37FEB',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerBehavior('clickSelected', {
      getEvents() {
        return {
          'node:click': 'onNodeClick',
          'canvas:click': 'onCanvasClick',
          'edge:click': 'onEdgeClick'
        }
      },
      onNodeClick(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        const selectedNodes = graph.findAllByState('node', 'selected')
        if (selectedNodes.length) {
          selectedNodes.forEach(node => {
            graph.clearItemStates(node, 'selected')
            graph.setItemState(node, 'show-anchor', false)
          })
        }
        let nodes = []
        if (!item.hasState('selected')) {
          item.setState('selected', true)
          nodes.push(item)
          graph.emit('select', nodes)
          setDetailPanel(item)
        }
        item.setState('show-anchor', true)
        const edges = graph.getEdges()
        const edgeCfg = {
          style: {
            lineWidth: 1
          }
        }
        edges.forEach(edge => {
          if (edge.hasState('selected')) {
            graph.clearItemStates(edge, 'selected')
            graph.updateItem(edge, edgeCfg, false)
          }
        })
      },
      onCanvasClick(e) {
        const self = this
        const graph = self.graph
        const nodes = graph.findAllByState('node', 'selected')
        const edges = graph.findAllByState('edge', 'selected')
        if (nodes.length) {
          nodes.forEach(node => {
            graph.clearItemStates(node, 'selected')
            graph.emit('unselect', nodes)
            if (node.hasState('show-anchor')) {
              graph.clearItemStates(node, 'show-anchor')
            }
          })
        }
        const edgeCfg = {
          style: {
            lineWidth: 1
          }
        }
        if (edges.length) {
          edges.forEach(edge => {
            graph.clearItemStates(edge, 'selected')
            graph.emit('unselect', edges)
            graph.updateItem(edge, edgeCfg, false)
          })
        }
        setDetailPanel('canvas')
      },
      onEdgeClick(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        const selectedEdges = graph.findAllByState('edge', 'selected')
        if (selectedEdges.length) {
          selectedEdges.forEach(edge => {
            graph.clearItemStates(edge, 'selected')
            const edgeCfg = {
              style: {
                lineWidth: 1
              }
            }
            graph.updateItem(edge, edgeCfg, false)
          })
        }
        if (!item.hasState('selected')) {
          item.setState('selected', true)
          const cfg = {
            style: {
              stroke: '#A3B1BF',
              lineWidth: 2,
              endArrow: {
                path: G6.Arrow.triangle(6, 8, 0),
                d: 0,
                fill: '#A3B1BF'
              }
            }
          }
          graph.updateItem(item, cfg, false)
          setDetailPanel(item)
          edges = []
          edges.push(item)
          graph.emit('select', edges)
          const nodes = graph.getNodes()
          nodes.forEach(node => {
            if (node.hasState('selected')) {
              graph.clearItemStates(node, 'selected')
            }
            if (node.hasState('show-anchor')) {
              graph.clearItemStates(node, 'show-anchor')
            }
          })
        }
      }
    })
    G6.registerBehavior('hoverNodeActived', {
      getEvents() {
        return {
          'node:mouseover': 'onMouseOver',
          'node:mouseleave': 'onMouseLeave',
        }
      },
      onMouseOver(e) {
        const { item } = e
        graph.setItemState(item, 'node-hover', true)
        if (!item.hasState('selected')) {
          item.setState('show-anchor', true)
        }
      },
      onMouseLeave(e) {
        const { item } = e
        graph.clearItemStates(item, 'node-hover', 'anchor-hover')
        if (!item.hasState('selected')) {
          item.setState('show-anchor', false)
        }
      }
    })
    G6.registerBehavior('hoverAnchorActived', {
      getEvents() {
        return {
          'node:mouseover': 'onMouseOver',
          'node:mouseout': 'onMouseOut'
        }
      },
      onMouseOver(e) {
        const self = this
        const graph = self.graph
        const { item } = e

        if (e.target.get('name') === 'anchor') {
          const index = e.target.get('index')
          graph.setItemState(item, 'anchor-hover', `${index}-hover`)
        }
      },
      onMouseOut(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        if (e.target.get('name') === 'anchor') {
          const index = e.target.get('index')
          graph.setItemState(item, 'anchor-hover', `${index}-leave`)
        }
      }
    })
    G6.registerBehavior('dragCanvasCursor', {
      getEvents() {
        return {
          'canvas:dragstart': 'onDragStart',
          'canvas:dragend': 'onDragEnd',
          'canvas:mousemove': 'onMouseMove'
        }
      },
      onMouseMove() {
        const self = this
        const graph = self.graph
        // 进入画布时，鼠标指针变为抓手
        graph.get('canvas').get('el').style.cursor = 'grab'
      },
      onDragStart() {
        const self = this
        const graph = self.graph
        // 拖拽画布时，鼠标指针变为拳头
        graph.get('canvas').get('el').style.cursor = 'grabbing'
      },
      onDragEnd() {
        const self = this
        const graph = self.graph
        // 鼠标释放时，还原鼠标指针
        graph.get('canvas').get('el').style.cursor = 'grab'
      }
    })
    G6.registerBehavior('dragPanelItemAddNode', {
      getEvents() {
        return {
          'canvas:mousemove': 'onMouseMove',
          'canvas:mouseup': 'onMouseUp',
          'canvas:mouseleave': 'onMouseLeave'
        }
      },
      onMouseMove(e) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          let delegateShape = graph.get('addDelegateShape')
          const addModel = graph.get('addModel')
          const { width, height } = addModel
          const point = graph.getPointByClient(e.x, e.y)
          const { x, y } = point
          if (!delegateShape) {
            const parent = graph.get('group')
            delegateShape = parent.addShape('rect', {
              attrs: {
                width: parseInt(width),
                height: parseInt(height),
                x: x - width / 2,
                y: y - height / 2,
                stroke: '#1890FF',
                fill: '#1890FF',
                fillOpacity: .08,
                lineDash: [4, 4],
                radius: 4,
                lineWidth: 1
              },
              name: 'delegateShape'
            })
            delegateShape.set('capture', false)
            graph.set('addDelegateShape', delegateShape)
          }
          delegateShape.attr({ x: x - width / 2, y: y - height / 2 })
          graph.paint()
          this.graph.emit('afternodedrag', delegateShape)
        }
      },
      onMouseUp(e) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          const point = graph.getPointByClient(e.clientX, e.clientY)
          self._addNode(point)
        }
      },
      onMouseLeave() {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          this._clearDelegate()
          graph.emit('afternodedragend')
        }
      },
      _addNode(point) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          const addModel = graph.get('addModel')
          const { type } = addModel
          const timestamp = new Date().getTime()
          const id = `${type}-${timestamp}`
          const { x, y } = point
          graph.addItem('node', {
            ...addModel,
            x,
            y,
            id
          }, true)
          this._clearDelegate()
          const selectedNodes = graph.findAllByState('node', 'selected')
          if (selectedNodes.length) {
            selectedNodes.forEach(node => {
              graph.clearItemStates(node, 'selected')
              // 清除状态并不会重绘，只会对现有属性进行更改
              graph.setItemState(node, 'show-anchor', false)
            })
          }
          graph.setItemState(id, 'show-anchor', true)
          graph.setItemState(id, 'selected', true)
          let nodes = []
          nodes.push(graph.findById(id))
          graph.emit('select', nodes)
          setDetailPanel(graph.findById(id))
        }
      },
      _clearDelegate() {
        const self = this
        const graph = self.graph
        const delegateShape = graph.get('addDelegateShape')
        if (delegateShape) {
          delegateShape.remove()
          graph.set('addDelegateShape', null)
          graph.paint()
        }
        graph.emit('afternodedragend')
      }
    })
    G6.registerBehavior('dragNode', {
      getEvents() {
        return {
          'node:dragstart': 'onDragStart',
          'node:drag': 'onDrag',
          'node:dragend': 'onDragEnd'
        }
      },
      onDragStart(e) {
        const self = this
        const graph = self.graph
        if (e.target.get('name') !== 'anchor') {
          const { item } = e
          if (!item.hasState('selected')) {
            item.clearStates('show-anchor')
          }
          const model = item.getModel()
          const { canvasX: x, canvasY: y } = e
          const { width, height } = model
          graph.addItem('node', {
            type: 'rect',
            x,
            y,
            style: {
              width: parseInt(width),
              height: parseInt(height),
              stroke: '#1890FF',
              fill: '#1890FF',
              fillOpacity: .08,
              lineDash: [4, 4],
              radius: 4,
              lineWidth: 1,
            },
            id: 'delegateShape',
          }, false)
          this.origin = {
            x: e.x - width / 2,
            y: e.y - height / 2
          }
        }
      },
      onDrag(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        if (e.target.get('name') !== 'anchor') {
          group.set('capture', false)
          const { item } = e
          const delegateShape = graph.findById('delegateShape')
          const bbox = item.getBBox()
          const { minX, minY } = bbox
          const clientX = e.x - this.origin.x + minX
          const clientY = e.y - this.origin.y + minY
          let delegateCfg = {
            x: clientX,
            y: clientY
          }
          delegateShape.updatePosition(delegateCfg)
          const delegateContainer = delegateShape.getBBox()
          const { minX: delegateMinX, minY: delegateMinY, maxX: delegateMaxX, maxY: delegateMaxY, centerX: delegateCenterX, centerY: delegateCenterY } = delegateContainer
          const nodes = graph.findAll('node', (node) => {
            return node.get('id') !== 'delegateShape'
          })
          let xNearNode
          let yNearNode
          let xDistance
          let yDistance
          // find nearest node
          nodes.forEach(node => {
            const { minX: nodeMinX, minY: nodeMinY, maxX: nodeMaxX, maxY: nodeMaxY, centerX: nodeCenterX, centerY: nodeCenterY } = node.getBBox()
            if (!xDistance) {
              xDistance = Math.abs(delegateMinX - nodeMinX)
              xNearNode = node
            }
            if (!yDistance) {
              yDistance = Math.abs(delegateMinY - nodeMinY)
              yNearNode = node
            }
            if (Math.abs(delegateMinX - nodeMinX) < xDistance) {
              xDistance = Math.abs(delegateMinX - nodeMinX)
              xNearNode = node
            }
            if (Math.abs(delegateMinY - nodeMinY) < yDistance) {
              yDistance = Math.abs(delegateMinY - nodeMinY)
              yNearNode = node
            }
          })

          const { minX: xNearNodeMinX, minY: xNearNodeMinY, maxX: xNearNodeMaxX, maxY: xNearNodeMaxY, centerX: xNearNodeCenterX, centerY: xNearNodeCenterY } = xNearNode.getBBox()
          const { minX: yNearNodeMinX, minY: yNearNodeMinY, maxX: yNearNodeMaxX, maxY: yNearNodeMaxY, centerX: yNearNodeCenterX, centerY: yNearNodeCenterY } = yNearNode.getBBox()
          let verticalStartPoint
          let verticalEndPoint
          let horizontalStartPoint
          let horizontalEndPoint
          const verticalAlignLine = group.findById('verticle-align-line')
          const horizontalAlignLine = group.findById('horizontal-align-line')
          const tolerance = 3
          if (Math.abs(delegateMinX - xNearNodeMinX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMinX) - xNearNodeCenterX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateMinX - xNearNodeMaxX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateCenterX - Math.floor(xNearNodeMinX)) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateCenterX - xNearNodeCenterX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateCenterX - Math.floor(xNearNodeMaxX)) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateMaxX - xNearNodeMinX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMaxX) - xNearNodeCenterX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateMaxX - xNearNodeMaxX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMinY
              }
            }
          }

          if (Math.abs(delegateMinY - yNearNodeMinY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMinY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMinY) - yNearNodeCenterY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeCenterY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeCenterY
              }
            }
          }
          if (Math.abs(delegateMinY - yNearNodeMaxY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMaxY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMaxY
              }
            }
          }
          if (Math.abs(delegateCenterY - Math.floor(yNearNodeMinY)) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMinY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMinY
              }
            }
          }
          if (Math.abs(delegateCenterY - yNearNodeCenterY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeCenterY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeCenterY
              }
            }
          }
          if (Math.abs(delegateCenterY - Math.floor(yNearNodeMaxY)) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMaxY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMaxY
              }
            }
          }
          if (Math.abs(delegateMaxY - yNearNodeMinY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMinY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMaxY) - yNearNodeCenterY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeCenterY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeCenterY
              }
            }
          }
          if (Math.abs(delegateMaxY - yNearNodeMaxY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMaxY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMaxY
              }
            }
          }

          if (!verticalAlignLine) {
            group.addShape('path', {
              attrs: {
                path: [
                  ['M', xNearNodeCenterX, xNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                stroke: '#FA8C16',
                opacity: 0,
                lineWidth: 1
              },
              id: 'verticle-align-line'
            })
          } else {
            if (verticalStartPoint && verticalEndPoint) {
              verticalAlignLine.attr({
                path: [
                  ['M', verticalStartPoint.x, verticalStartPoint.y],
                  ['L', verticalEndPoint.x, verticalEndPoint.y]
                ],
                opacity: 0.8
              })
            } else {
              verticalAlignLine.attr({
                path: [
                  ['M', xNearNodeCenterX, xNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                opacity: 0
              })
            }
          }

          if (!horizontalAlignLine) {
            group.addShape('path', {
              attrs: {
                path: [
                  ['M', yNearNodeCenterX, yNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                stroke: '#FA8C16',
                opacity: 1,
                lineWidth: 1
              },
              id: 'horizontal-align-line'
            })
          } else {
            if (horizontalStartPoint && horizontalEndPoint) {
              horizontalAlignLine.attr({
                path: [
                  ['M', horizontalStartPoint.x, horizontalStartPoint.y],
                  ['L', horizontalEndPoint.x, horizontalEndPoint.y]
                ],
                opacity: 0.8
              })
            } else {
              horizontalAlignLine.attr({
                path: [
                  ['M', yNearNodeCenterX, yNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                opacity: 0
              })
            }
          }
        }
      },
      onDragEnd(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        if (e.target.get('name') !== 'anchor') {
          const verticalAlignLine = group.findById('verticle-align-line')
          const horizontalAlignLine = group.findById('horizontal-align-line')
          group.removeChild(verticalAlignLine)
          group.removeChild(horizontalAlignLine)
          const { item } = e

          const delegateShape = graph.findById('delegateShape')
          const { x, y, width, height } = delegateShape.getBBox()
          const clientX = x + parseInt(width / 2)
          const clientY = y + parseInt(height / 2)
          const cfg = {
            x: clientX,
            y: clientY
          }
          graph.updateItem(item, cfg, true)

          const selectedNodes = graph.findAllByState('node', 'selected')
          selectedNodes.forEach(node => {
            graph.clearItemStates(node, 'selected')
          })
          graph.setItemState(item, 'selected', true)
          const nodes = []
          nodes.push(item)
          graph.emit('select', nodes)
          graph.setItemState(item, 'show-anchor', true)
          graph.removeItem(delegateShape, false)
          this.origin = null
          const edges = graph.getEdges()
          const edgeCfg = {
            style: {
              lineWidth: 1
            }
          }
          edges.forEach(edge => {
            if (edge.hasState('selected')) {
              graph.clearItemStates(edge, 'selected')
              graph.emit('unselect', edges)
              graph.updateItem(edge, edgeCfg)
            }
          })
        }
        group.set('capture', true)
      }
    })
    G6.registerBehavior('dragPoint', {
      getEvents() {
        return {
          'node:dragstart': 'onDragStart',
          'node:drag': 'onDrag',
          'node:dragend': 'onDragEnd',
          'node:dragenter': 'onDragEnter',
          'node:dragleave': 'onDragLeave',
          'node:drop': 'onDrop'
        }
      },
      onDragStart(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        if (e.target.get('name') === 'anchor') {
          const { canvasX: x, canvasY: y, item } = e
          group.addShape('path', {
            attrs: {
              path: [
                ['M', x, y],
                ['L', x, y]
              ],

              stroke: '#1890FF',
              lineWidth: 1,
              lineDash: [4, 4]
            },
            id: 'delegate-edge'
          })
          const index = e.target.get('index')
          const id = item.get('id')
          graph.set('sourceNode', {
            item,
            sourceAnchor: index
          })
          const nodes = graph.getNodes()
          nodes.forEach(node => {
            node.setState('show-anchor', true)
            node.setState('show-hotspots', `${id},${index},inactive`)
          })
        }
      },
      onDrag(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')

        if (e.target.get('name') === 'anchor') {
          const { x, y, item } = e
          const index = e.target.get('index')
          const { minX, minY, centerX, centerY, maxX, maxY } = item.getBBox()
          const anchors = [
            {
              x: centerX,
              y: minY
            },
            {
              x: maxX,
              y: centerY
            },
            {
              x: centerX,
              y: maxY
            },
            {
              x: minX,
              y: centerY
            }
          ]
          delegateEdge.attr({
            path: [
              ['M', anchors[index].x, anchors[index].y],
              ['L', x, y]
            ],
          })
        }
      },
      onDragEnd(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')
        if (e.target.get('name') === 'anchor') {
          const { item } = e
          const nodes = graph.getNodes()
          if (item.hasState('selected')) {
            graph.clearItemStates(item, 'selected')
          }
          group.removeChild(delegateEdge)
          nodes.forEach(node => {
            node.setState('show-anchor', false)
            node.setState('show-hotspots', 'all,all,clear')
          })
        }
      },
      onDragEnter(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')
        const index = e.target.get('index')
        const { item } = e
        if (e.target.get('name') === 'anchor-marker' || e.target.get('name') === 'anchor') {
          if (delegateEdge) {
            delegateEdge.set('zIndex', -1)
            group.sort()
          }
          item.setState('hotspot-hover', `${index}-hover`)
        }
      },
      onDragLeave(e) {
        const index = e.target.get('index')
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')
        const { item } = e
        if (e.target.get('name') === 'anchor-marker') {
          if (delegateEdge) {
            delegateEdge.set('zIndex', 1)
            group.sort()
          }
          item.setState('hotspot-hover', `${index}-leave`)
        }
      },
      onDrop(e) {
        const targetAnchor = e.target.get('index')
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const { item: target } = e
        const { item: source, sourceAnchor } = graph.get('sourceNode')
        const delegateEdge = group.findById('delegate-edge')
        if (delegateEdge) {
          group.removeChild(delegateEdge)
        }

        let curvePosition = [1 / 2, 1 / 2]
        let curveOffset = [-20, 20]
        let edgeType = 'cubic'
        const timestamp = new Date().getTime()
        const id = `line-${timestamp}`
        graph.addItem('edge', {
          id,
          type: edgeType,
          source,
          target,
          sourceAnchor,
          targetAnchor,
          curvePosition,
          curveOffset,
          style: {
            stroke: '#A3B1BF',
            lineWidth: 1,
            lineAppendWidth: 8,
            endArrow: {
              path: G6.Arrow.triangle(6, 8, 0),
              d: 0,
              fill: '#A3B1BF',
            }
          },
        }, true)
        const edgeGroup = graph.get('edgeGroup')
        edgeGroup.toFront()
      }
    })
    G6.registerBehavior('hoverEdgeActived', {
      getEvents() {
        return {
          'edge:mouseover': 'onMouseOver',
          'edge:mouseleave': 'onMouseLeave'
        }
      },
      onMouseOver(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        if (!item.hasState('selected')) {
          const cfg = {
            style: {
              stroke: '#1890FF',
              endArrow: {
                path: G6.Arrow.triangle(6, 8, 0),
                d: 0,
                fill: '#1890FF'
              }
            }
          }
          graph.updateItem(item, cfg, false)
        }
      },
      onMouseLeave(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        if (!item.hasState('selected')) {
          const cfg = {
            style: {
              stroke: '#A3B1BF',
              endArrow: {
                path: G6.Arrow.triangle(6, 8, 0),
                d: 0,
                fill: '#A3B1BF'
              }
            }
          }
          graph.updateItem(item, cfg, false)
        }
      }
    })
    G6.registerBehavior('deleteItem', {
      getEvents() {
        return {
          'keydown': 'onKeydown'
        }
      },
      onKeydown(e) {
        const self = this
        const graph = self.graph
        const nodes = graph.findAllByState('node', 'selected')
        const edges = graph.findAllByState('edge', 'selected')
        const { keyCode } = e
        if (keyCode === 46) {
          // 先删除edge，因为删除 node 的同时， edge 也不复存在，无法再次删除
          if (edges) {
            edges.forEach((edge) => {
              graph.removeItem(edge, true)
            })
            graph.emit('unselect', edges)
          }
          if (nodes) {
            nodes.forEach((node) => {
              graph.removeItem(node, true)
            })
            graph.emit('unselect', nodes)
          }
        }
      }
    })
    G6.registerBehavior('contextMenu', {
      getEvents() {
        return {
          'canvas:contextmenu': 'onCanvasContextMenu',
          'canvas:click': 'onCanvasClick',
          'node:contextmenu': 'onNodeContextMenu',
          'edge:contextmenu': 'onEdgeContextMenu'
        }
      },
      onCanvasContextMenu(e) {
        e.preventDefault()
        e.stopPropagation()
        const { canvasX, canvasY, x, y } = e
        showMenu('canvas', canvasX, canvasY)
        // 清除所有节点选中状态
        const nodes = graph.findAllByState('node', 'selected')
        nodes.forEach(node => {
          graph.clearItemStates(node, 'selected')
          graph.setItemState(node, 'show-anchor', false)
        })
        const menu = document.querySelector('.context-menu')
        const undoStack = graph.getUndoStack()
        const redoStack = graph.getRedoStack()
        const undoMenu = document.querySelector('.context-menu li[data-command="undo"]')
        const redoMenu = document.querySelector('.context-menu li[data-command="redo"]')
        const pasteHereMenu = document.querySelector('.context-menu li[data-command="pasteHere"]')
        if (undoStack.length === 1) {
          undoMenu.classList.add('disabled')
          undoMenu.setAttribute('style', 'cursor: not-allowed')
        } else {
          undoMenu.classList.remove('disabled')
          undoMenu.removeAttribute('style')
        }
        if (redoStack.length === 0) {
          redoMenu.classList.add('disabled')
          redoMenu.setAttribute('style', 'cursor: not-allowed')
        } else {
          redoMenu.classList.remove('disabled')
          redoMenu.removeAttribute('style')
        }
        if (clipboard.length === 0) {
          pasteHereMenu.classList.add('disabled')
          pasteHereMenu.setAttribute('style', 'cursor: not-allowed')
        } else {
          pasteHereMenu.classList.remove('disabled')
          pasteHereMenu.removeAttribute('style')
        }
        let item
        menu.addEventListener('click', e => {
          if (e.target.matches('span')) {
            item = e.target.parentElement
          }
          if (e.target.matches('li')) {
            item = e.target
          }
          if (e.target.matches('svg')) {
            item = e.target.parentElement.parentElement
          }
          if (e.target.matches('path')) {
            item = e.target.parentElement.parentElement.parentElement
          }
          const { command } = item.dataset
          switch (command) {
            case 'undo':
              undo()
              break
            case 'redo':
              redo()
              break
            case 'pasteHere':
              if (clipboard.length) {
                paste(x, y)
              }
              break
          }
        })
      },
      onNodeContextMenu(e) {
        e.preventDefault()
        e.stopPropagation()
        const { canvasX, canvasY } = e
        showMenu('node', canvasX, canvasY)
        const menu = document.querySelector('.context-menu')
        let item
        let currentNode = e.item
        menu.addEventListener('click', e => {
          if (e.target.matches('span')) {
            item = e.target.parentElement
          }
          if (e.target.matches('li')) {
            item = e.target
          }
          if (e.target.matches('svg')) {
            item = e.target.parentElement.parentElement
          }
          if (e.target.matches('path')) {
            item = e.target.parentElement.parentElement.parentElement
          }
          const { command } = item.dataset
          let nodes = []
          switch (command) {
            case 'copy':
              nodes.push(currentNode)
              copy(nodes)
              break
            case 'delete':
              nodes.push(currentNode)
              graph.removeItem(currentNode, true)
              graph.emit('unselect', nodes)
              menuContainer.setAttribute('style', `display:none`)
              break
            default:
          }
        })
      },
      onEdgeContextMenu(e) {
        e.preventDefault()
        e.stopPropagation()
        const { canvasX, canvasY } = e
        showMenu('edge', canvasX, canvasY)
        const menu = document.querySelector('.context-menu')
        let item
        let currentEdge = e.item
        menu.addEventListener('click', e => {
          if (e.target.matches('span')) {
            item = e.target.parentElement
          }
          if (e.target.matches('li')) {
            item = e.target
          }
          if (e.target.matches('svg')) {
            item = e.target.parentElement.parentElement
          }
          if (e.target.matches('path')) {
            item = e.target.parentElement.parentElement.parentElement
          }
          const { command } = item.dataset
          switch (command) {
            case 'delete':
              let edges = []
              edges.push(currentEdge)
              graph.emit('unselect', edges)
              graph.removeItem(currentEdge, true)
              menuContainer.setAttribute('style', `display:none`)
              break
            default:
          }
        })
      },
      onCanvasClick(e) {
        menuContainer.setAttribute('style', `display:none`)
      }
    })
    /**
    * undo 操作
    */
    function undo() {
      const undoStack = graph.getUndoStack()
      if (!undoStack || undoStack.length === 1) {
        return
      }
      const currentData = undoStack.pop()
      if (currentData) {
        const { action } = currentData
        graph.pushStack(action, clone(currentData.data), 'redo')
        let data = currentData.data.before

        if (action === 'add') {
          data = currentData.data.after;
        }

        if (!data) return
        switch (action) {
          case 'visible': {
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                const item = graph.findById(model.id)
                if (model.visible) {
                  graph.showItem(item, false)
                } else {
                  graph.hideItem(item, false)
                }
              })
            })
            break
          }
          case 'render':
          case 'update':
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                graph.updateItem(model.id, model, false)
              })
            })
            break
          case 'changedata':
            graph.changeData(data, false)
            break
          case 'delete': {
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                const itemType = model.itemType
                delete model.itemType
                graph.addItem(itemType, model, false)
              })
            })
            break
          }
          case 'add':
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                graph.removeItem(model.id, false)
              })
            })
            break
          default:
        }
        menuContainer.setAttribute('style', `display:none`)
      }
    }
    /**
    * redo 操作
    */
    function redo() {
      const redoStack = graph.getRedoStack()
      if (!redoStack || redoStack.length === 0) {
        return
      }

      const currentData = redoStack.pop()
      if (currentData) {
        const { action } = currentData
        let data = currentData.data.after
        graph.pushStack(action, clone(currentData.data), 'undo')
        if (action === 'delete') {
          data = currentData.data.before;
        }

        if (!data) return
        switch (action) {
          case 'visible': {
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                const item = graph.findById(model.id)
                if (model.visible) {
                  graph.showItem(item, false)
                } else {
                  graph.hideItem(item, false)
                }
              })
            })
            break
          }
          case 'render':
          case 'update':
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                graph.updateItem(model.id, model, false)
              })
            })
            break
          case 'changedata':
            graph.changeData(data, false)
            break
          case 'delete':
            if (data.edges) {
              data.edges.forEach(model => {
                graph.removeItem(model.id, false)
              })
            }
            if (data.nodes) {
              data.nodes.forEach(model => {
                graph.removeItem(model.id, false)
              })
            }
            break
          case 'add': {
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                const itemType = model.itemType
                delete model.itemType
                graph.addItem(itemType, model, false)
              })
            })
          }
        }
        menuContainer.setAttribute('style', `display:none`)
      }
    }
    function updateItem(element, type, target) {
      if (type === 'label') {
        element.addEventListener('change', e => {
          const label = e.target.value
          const cfg = {
            label,
            labelCfg: {
              style: {
                background: {
                  fill: '#ffffff',
                  padding: [2, 2, 2, 2],
                }
              }
            }
          }
          /** 
          * node 的 label 无背景
          */
          if (target.get('type') === 'node') {
            delete cfg.labelCfg.style
          }
          graph.updateItem(target, cfg, true)
        })
      }

      if (type === 'shape') {
        element.addEventListener('change', e => {
          const { value } = e.target
          let type
          let radius = 0
          if (value === 'Smooth') {
            type = 'cubic'
          }
          if (value === 'Polyline') {
            type = 'polyline'
          }
          if (value === 'Polyline Round') {
            type = 'polyline'
            radius = 5
          }
          // 由于未使用 state，style 更新则会覆盖原有的 style，已有属性需要重新指定
          graph.updateItem(target, {
            type,
            style: {
              stroke: '#A3B1BF',
              lineWidth: 2,
              endArrow: {
                path: G6.Arrow.triangle(6, 8, 0),
                d: 0,
                fill: '#A3B1BF'
              },
              radius,
              offset: 14
            }
          }, true)
        })
      }
    }
    function setDetailPanel(item) {
      const detailPanelTitle = document.querySelector('#property-title')
      const propertyContainer = document.querySelector('.property')

      const labelRow = document.createElement('div')
      labelRow.className = 'row'
      const labelLabel = document.createElement('div')
      labelLabel.innerHTML = 'Label'
      labelLabel.className = 'label'
      labelRow.appendChild(labelLabel)
      const labelInput = document.createElement('input')
      labelInput.className = 'input'
      labelRow.appendChild(labelInput)

      const shapeRow = document.createElement('div')
      shapeRow.className = 'row'
      const shapeLabel = document.createElement('div')
      shapeLabel.innerHTML = 'Shape'
      shapeLabel.className = 'label'
      shapeRow.appendChild(shapeLabel)
      const shapeSelect = document.createElement('select')
      shapeSelect.className = 'input'
      shapeRow.appendChild(shapeSelect)
      const shapeOptions = ['Smooth', 'Polyline', 'Polyline Round']
      shapeOptions.forEach((option, index) => {
        const op = document.createElement('option')
        op.value = option
        op.text = option
        shapeSelect.appendChild(op)
      })
      if (item === 'canvas') {
        detailPanelTitle.innerHTML = 'Canvas'
        if (propertyContainer.children.length) {
          propertyContainer.innerHTML = ''
        }
      } else {
        if (item.getType() === 'node') {
          const { label } = item.getModel()
          detailPanelTitle.innerHTML = 'Node'
          propertyContainer.innerHTML = ''
          propertyContainer.appendChild(labelRow)
          labelInput.value = label
          updateItem(labelInput, 'label', item)
        }
        if (item.getType() === 'edge') {
          let { label, type, style } = item.getModel()
          if (!label) {
            label = ''
          }
          labelInput.value = label
          let shape
          if (type === 'cubic') {
            shape = 'Smooth'
          }
          if (type === 'polyline') {
            shape = 'Polyline'
            if (style.radius > 0) {
              shape = 'Polyline Round'
            }
          }
          shapeSelect.value = shape
          propertyContainer.innerHTML = ''
          detailPanelTitle.innerHTML = 'Edge'
          propertyContainer.appendChild(labelRow)
          propertyContainer.appendChild(shapeRow)
          updateItem(labelInput, 'label', item)
          updateItem(shapeSelect, 'shape', item)
        }
      }
    }
    function showMenu(name, x, y) {
      let menuDom
      if (name === 'canvas') {
        menuDom = `
          <ul class="context-menu" data-status="canvas-selected">
            <li class="menu" data-command="undo"><span role="img"><svg id="icon-undo" viewBox="0 0 1024 1024"><path d="M143.14 449.19q69.07-89.09 170.67-140.64Q415.41 257 537.52 256q183.18 4 315.81 114.11T1024 654.39q-58.06-107.11-161.66-170.17-103.6-63.06-232.73-65.06-107.1 1-196.69 45.54-89.58 44.55-152.65 121.62L407.4 713.45q7 7 7 17.01 0 10.01-7 17.02t-17.01 7.01H32.04q-14.01 0-23.02-9.01T0.01 722.46V364.11q0-10.01 7-17.02t17.02-7.01q10.01 0 17.02 7.01l102.1 102.1z"></path></svg></span><span>Undo</span></li>
            <li class="menu" data-command="redo"><span role="img"><svg id="icon-redo" viewBox="0 0 1024 1024"><path d="M999.98 340.08q-10.01 0-17.02 7.01l-102.1 102.1q-69.07-89.09-170.67-140.64Q608.59 257 487.48 256q-184.18 4-316.81 114.11T0 654.39q58.06-107.11 161.66-170.17 103.6-63.06 232.73-65.06 107.1 1 197.19 45.54 90.09 44.55 152.15 121.62L616.6 713.45q-7 7-7 17.01 0 10.01 7 17.02t17.01 7.01h358.35q14.01 0 23.02-9.01t9.01-23.02V364.11q0-10.01-7-17.02t-17.01-7.01z"></path></svg></span><span>Redo</span></li>
            <li class="menu" data-command="pasteHere"><span role="img"><svg id="icon-paste" viewBox="0 0 1024 1024"><path d="M795.99 199.33h-75.02v-62.16h109.31q10.72 0 19.3 8.58 8.57 8.57 8.57 19.29v102.88h-62.16v-68.59zM240.87 898.05h-75.02V199.33h75.02v-62.16H131.56q-10.72 0-19.29 8.58-8.57 8.57-8.57 19.29v760.88q0 10.71 8.57 18.75t19.29 9.11h102.88l6.43-55.73z m411.52-623.7H309.46V137.17h68.58V62.16q1.07-26.8 18.22-43.94Q413.41 1.08 440.2 0.01h75.01q26.8 1.07 43.94 18.21 17.14 17.14 18.22 43.94v75.01h75.02v137.18zM515.21 62.16H440.2v75.01h75.01V62.16z m405.09 938.77V548.69L720.97 342.93H343.75q-16.08 0-25.19 8.57-9.11 8.57-9.11 19.3v623.7q0 10.72 8.57 18.76 8.57 8.04 19.29 9.11H886q15 4.28 24.11-2.68 9.11-6.97 10.18-18.76z m-68.58-438.31H714.54v-151.1l137.18 151.1z m6.43 411.52H371.61V411.52h280.78v212.19h205.76v350.43z"></path></svg></span><span>Paste Here</span></li>
          </ul>
        `
      }
      if (name === 'node') {
        menuDom = `
          <ul class="context-menu" data-status="canvas-selected">
            <li class="menu" data-command="copy"><span role="img"><svg id="icon-copy" viewBox="0 0 1024 1024"><path d="M990.08 1017.64h-549.1q-10.6 0-18.55-8.48-7.95-8.48-9.01-19.08V373.13q1.06-10.6 10.07-18.55 9.01-7.95 23.85-9.01h373.13L1024 549.1v448.4q-5.3 5.3-14.31 12.19-9.01 6.89-19.61 7.95zM814.11 407.06v135.68H949.8L814.11 407.06zM949.8 610.58H746.27V407.06H474.9V949.8h474.9V610.58z m-610.59 67.85H67.84V67.84h271.37v203.53h271.37v-67.84L407.06 0H33.92Q18.02 0 9.01 8.48T0 27.56v684.79q0 10.6 8.48 18.55 8.48 7.95 19.08 9.01h311.65v-61.48z m67.85-610.59l135.68 135.69H407.06V67.84z"></path></svg></span><span>Copy</span></li>
            <li class="menu" data-command="delete"><span role="img"><svg id="icon-delete" viewBox="0 0 1024 1024"><path d="M828.55 311.65q-17.81 0-30.05 11.13-12.25 11.13-14.47 28.94l-52.32 529.81h-95.72l16.7-461.91q0-14.47-10.02-25.05-10.02-10.57-25.05-11.13-15.02-0.56-25.6 8.91-10.58 9.46-10.58 25.04l-16.69 464.14H459.01l-15.58-465.25q-1.12-15.58-11.69-25.04-10.57-9.47-25.6-8.91-15.03 0.56-24.49 11.13-9.46 10.57-9.46 25.04l15.58 463.03h-94.6l-52.32-529.81q-2.22-17.81-14.47-28.94-12.24-11.13-30.05-11.13h-3.34q-15.58 2.23-25.04 13.36-9.46 11.13-8.35 26.71l60.1 599.93q3.34 31.17 25.6 51.21 22.26 20.03 53.43 21.14h426.3q31.16-1.11 53.42-21.14t26.72-51.21l58.99-603.27q0-15.58-10.57-26.15-10.58-10.58-25.05-10.58z m107.96-71.23l-7.79-61.22q-5.56-35.62-31.72-57.88-26.15-22.26-61.77-23.37h-170.3l-3.34-32.28q-2.22-28.94-22.25-46.75Q619.3 1.11 590.36 0H433.42Q404.48 1.11 385 18.92q-19.48 17.81-22.82 46.75l-2.22 32.28H188.55q-35.62 1.11-61.22 23.37T96.17 179.2l-8.91 63.44q0 7.79 5.01 12.8 5.01 5.01 12.8 5.01h816.98q6.67-1.11 11.13-6.68 4.46-5.56 3.34-13.35zM422.29 97.95l2.22-27.83q1.12-6.68 8.91-7.79h158.05q6.68 1.11 8.91 7.79l1.11 27.83h-179.2z"></path></svg></span><span>Delete</span></li>
          </ul>
        `
      }
      if (name === 'edge') {
        menuDom = `
          <ul class="context-menu" data-status="canvas-selected">
            <li class="menu" data-command="delete"><span role="img"><svg id="icon-delete" viewBox="0 0 1024 1024"><path d="M828.55 311.65q-17.81 0-30.05 11.13-12.25 11.13-14.47 28.94l-52.32 529.81h-95.72l16.7-461.91q0-14.47-10.02-25.05-10.02-10.57-25.05-11.13-15.02-0.56-25.6 8.91-10.58 9.46-10.58 25.04l-16.69 464.14H459.01l-15.58-465.25q-1.12-15.58-11.69-25.04-10.57-9.47-25.6-8.91-15.03 0.56-24.49 11.13-9.46 10.57-9.46 25.04l15.58 463.03h-94.6l-52.32-529.81q-2.22-17.81-14.47-28.94-12.24-11.13-30.05-11.13h-3.34q-15.58 2.23-25.04 13.36-9.46 11.13-8.35 26.71l60.1 599.93q3.34 31.17 25.6 51.21 22.26 20.03 53.43 21.14h426.3q31.16-1.11 53.42-21.14t26.72-51.21l58.99-603.27q0-15.58-10.57-26.15-10.58-10.58-25.05-10.58z m107.96-71.23l-7.79-61.22q-5.56-35.62-31.72-57.88-26.15-22.26-61.77-23.37h-170.3l-3.34-32.28q-2.22-28.94-22.25-46.75Q619.3 1.11 590.36 0H433.42Q404.48 1.11 385 18.92q-19.48 17.81-22.82 46.75l-2.22 32.28H188.55q-35.62 1.11-61.22 23.37T96.17 179.2l-8.91 63.44q0 7.79 5.01 12.8 5.01 5.01 12.8 5.01h816.98q6.67-1.11 11.13-6.68 4.46-5.56 3.34-13.35zM422.29 97.95l2.22-27.83q1.12-6.68 8.91-7.79h158.05q6.68 1.11 8.91 7.79l1.11 27.83h-179.2z"></path></svg></span><span>Delete</span></li>
          </ul>
        `
      }
      menuContainer.innerHTML = menuDom
      menuContainer.setAttribute('style', `position:absolute;left:${x}px;top:${y}px`)
    }
    let clipboard = []
    function copy(nodes) {
      clipboard = []
      if (nodes && nodes.length) {
        nodes.forEach(node => {
          clipboard.push({
            type: node.get('type'),
            model: node.getModel()
          })
        })
      }
      graph.emit('copy', nodes)
      menuContainer.setAttribute('style', `display:none`)
    }
    /**
    * edge 的粘贴没有实际意义，只需考虑 node
    */
    function paste(x, y) {
      const timestamp = new Date().getTime()
      if (clipboard.length === 1) {
        const model = clipboard[0].model
        const id = `${model.type}-${timestamp}`
        model.id = id
        model.x = model.x + 10
        model.y = model.y + 10
        if (x && y) {
          model.x = x + parseInt(model.width / 2)
          model.y = y + parseInt(model.height / 2)
        }
        let nodes = []
        nodes.push(clipboard[0])
        graph.emit('unselect', nodes)
        graph.addItem('node', model, true)
      }

      if (clipboard.length > 1) {
        let xDistance
        let yDistance
        let stackData = {
          before: {},
          after: {
            nodes: [],
            edges: [],
            combos: []
          }
        }
        clipboard.forEach((node, index) => {
          const model = node.model
          const id = `${model.type}-${timestamp}-${index}`
          model.id = id
          if (x && y) {
            if (index === 0) {
              xDistance = x - model.x
              yDistance = y - model.y
            }
            model.x = model.x + xDistance + model.width / 2
            model.y = model.y + yDistance
          } else {
            model.x = model.x + 10
            model.y = model.y + 10
          }
          model.itemType = 'node'
          stackData.after.nodes.push(model)
          graph.addItem('node', model, false)
        })
        graph.pushStack('add', clone(stackData))
      }

      menuContainer.setAttribute('style', `display:none`)
    }
    function isType(value, type) {
      const toString = {}.toString
      return toString.call(value) === '[object ' + type + ']'
    }
    function isArray(value) {
      return Array.isArray ?
        Array.isArray(value) :
        isType(value, 'Array')
    }
    function clone(obj) {
      if (typeof obj !== 'object' || obj === null) {
        return obj
      }
      let rst
      if (isArray(obj)) {
        rst = []
        for (let i = 0, l = obj.length; i < l; i++) {
          if (typeof obj[i] === 'object' && obj[i] != null) {
            rst[i] = clone(obj[i])
          } else {
            rst[i] = obj[i]
          }
        }
      } else {
        rst = {}
        for (const k in obj) {
          if (typeof obj[k] === 'object' && obj[k] != null) {
            rst[k] = clone(obj[k])
          } else {
            rst[k] = obj[k]
          }
        }
      }
      return rst
    }

    const graph = new G6.Graph({
      container: canvas,
      width: container.clientWidth - 480,
      height: container.clientHeight,
      modes: {
        default: [
          {
            type: 'drag-canvas'
          }
        ],
        brushSelect: [
          {
            type: 'brush-select',
            trigger: 'drag',
            includeEdges: false,
            onSelect: (nodes) => {
              if (nodes.length) {
                graph.emit('select', nodes)
              }
            },
          }
        ],
        edit: [
          'drag-canvas',
          'dragPanelItemAddNode',
          'dragNode',
          'dragCanvasCursor',
          'hoverAnchorActived',
          'hoverNodeActived',
          'clickSelected',
          'dragPoint',
          'hoverEdgeActived',
          'deleteItem',
          'contextMenu'
        ]
      },
      plugins: [minimap],
      enabledStack: true
    })

    graph.setMode('edit')
    graph.render()
    graph.on('stackchange', e => {
      const undoStack = graph.getUndoStack()
      const redoStack = graph.getRedoStack()
      const undoMenu = document.querySelector('li[data-command="undo"]')
      const redoMenu = document.querySelector('li[data-command="redo"]')
      if (undoStack.length === 1) {
        if (undoMenu) {
          undoMenu.classList.add('disabled')
          undoMenu.setAttribute('style', 'cursor: not-allowed')
        }
      } else {
        if (undoMenu) {
          undoMenu.classList.remove('disabled')
          undoMenu.removeAttribute('style')
        }
      }
      if (redoStack.length === 0) {
        if (redoMenu) {
          redoMenu.classList.add('disabled')
          redoMenu.setAttribute('style', 'cursor: not-allowed')
        }
      } else {
        if (redoMenu) {
          redoMenu.classList.remove('disabled')
          redoMenu.removeAttribute('style')
        }
      }
    })
    graph.on('dragend', e => {
      const mode = graph.getCurrentMode()
      if (mode === 'brushSelect') {
        setTimeout(() => {
          graph.setMode('edit')
        }, 0)
      }
    })
    graph.on('copy', e => {
      const pasteItem = document.querySelector('.toolbar li[data-command="paste"]')
      pasteItem.classList.remove('disabled')
      pasteItem.removeAttribute('style')
    })
    graph.on('select', e => {
      const deleteItem = document.querySelector('.toolbar li[data-command="delete"]')
      deleteItem.classList.remove('disabled')
      deleteItem.removeAttribute('style')

      const copyItem = document.querySelector('.toolbar li[data-command="copy"]')
      copyItem.classList.remove('disabled')
      copyItem.removeAttribute('style')
    })
    graph.on('unselect', e => {
      const deleteItem = document.querySelector('.toolbar li[data-command="delete"]')
      deleteItem.classList.add('disabled')
      deleteItem.setAttribute('style', 'cursor: not-allowed')

      const copyItem = document.querySelector('.toolbar li[data-command="copy"]')
      copyItem.classList.add('disabled')
      copyItem.setAttribute('style', 'cursor: not-allowed')
    })
  </script>
</body>

</html>