<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flow Editor</title>
  <style>
    html {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    * {
      box-sizing: border-box;
    }

    body {
      background: #F0F2F5;
      margin: 0;
      height: 100%;
      overflow: hidden;
      font-size: 14px;
    }

    .editor {
      margin: 24px;
      background: #fff;
      height: calc(100% - 48px);
    }

    .toolbar {
      height: 44px;
      background: #FAFAFA;
      box-shadow: 0 -1px 0 inset rgba(0, 0, 0, 0.08);
      ;
    }

    .container {
      display: flex;
      height: calc(100% - 44px);
    }

    .item-panel {
      width: 240px;
      box-shadow: -1px 0 0 inset rgba(0, 0, 0, 0.08);
      padding: 24px;
    }

    .items {
      margin: 0;
      padding: 0;
    }

    .items li.item {
      list-style: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 24px;
      cursor: pointer;
    }

    .items li.item:last-child {
      margin-bottom: 0;
    }

    .detail-panel {
      width: 240px;
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      padding: 10px 16px;
      background: #FAFAFA;
      box-shadow: 0 -1px 0 inset rgba(0, 0, 0, 0.08);
    }

    .property {
      flex: 1;
      padding: 16px;
    }

    .property .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .property .row .label {
      text-align: right;
      margin-right: 8px;
    }

    .property .row .input {
      font-variant: tabular-nums;
      width: 100%;
      padding: 4px 11px;
      border: 1px solid #d9d9d9;
      border-radius: 2px;
      line-height: 1.5715;
      color: rgba(0, 0, 0, .85);
    }

    .property .row .input:focus {
      border-color: #40a9ff;
      outline: 0;
      box-shadow: 0 0 0 2px rgba(24, 144, 255, .2);
    }

    .property .row .input:hover {
      border-color: #40a9ff;
    }

    .property .row .label::after {
      content: ':'
    }

    .canvas {
      flex: 1;
      box-shadow: -1px 0 0 inset rgba(0, 0, 0, 0.08);
    }
  </style>
</head>

<body>
  <div class="editor">
    <div class="toolbar">

    </div>
    <div class="container">
      <div class="item-panel">
        <ul class="items">
          <li class="item" data-type="start" data-width="72" data-height="72" data-label="Start">
            <img src="assets/flow/start.svg" alt="Start">
          </li>
          <li class="item" data-type="process" data-width="84" data-height="46" data-label="Process">
            <img src="assets/flow/process.svg" alt="Process">
          </li>
          <li class="item" data-type="decision" data-width="82" data-height="74" data-label="Decision">
            <img src="assets/flow/decision.svg" alt="Decision">
          </li>
          <li class="item" data-type="io" data-width="80" data-height="40" data-label="IO">
            <img src="assets/flow/io.svg" alt="IO">
          </li>
          <li class="item" data-type="terminal" data-width="80" data-height="48" data-label="Terminal">
            <img src="assets/flow/terminal.svg" alt="Terminal">
          </li>
        </ul>
      </div>
      <div class="canvas" id="canvas"></div>
      <div class="detail-panel">
        <div class="panel-header" id="property-title">Canvas</div>
        <div class="property"></div>
        <div class="panel-header">Minimap</div>
        <div class="minimap"></div>
      </div>
    </div>
  </div>
  <script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.6.1/dist/g6.min.js"></script>
  <script>
    const container = document.querySelector('.container')
    const items = document.querySelectorAll('.items .item')
    const img = new Image()
    img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'

    items.forEach(item => {
      const { type, width, height, label } = item.dataset
      const addModel = {
        type,
        width,
        height,
        label
      }
      item.addEventListener('dragstart', e => {
        e.dataTransfer.setDragImage(img, 0, 0)
        graph.set('addNodeDragging', true)
        graph.set('addModel', addModel);
      })
      item.addEventListener('drag', e => {
        graph.emit('canvas:mousemove', e);
      })
      item.addEventListener('dragend', e => {
        graph.emit('canvas:mouseup', e);
        graph.set('addNodeDragging', false);
        graph.set('addModel', null);
      })
    })
    const nodeStyle = {
      shadowOffsetX: 0,
      shadowOffsetY: 4,
      shadowBlur: 10,
      shadowColor: 'rgba(13, 26, 38, 0.1)',
      lineWidth: 1
    }
    const minimapContainer = document.querySelector('.minimap')
    const minimap = new G6.Minimap({
      size: [240, 200],
      container: minimapContainer
    })
    G6.registerNode('start', {
      drawShape(cfg, group) {
        const { width, height, x, y, label, id } = cfg
        const shape = group.addShape('circle', {
          attrs: {
            id,
            width,
            height,
            r: width / 2,
            stroke: '#FFC069',
            fill: '#FFF2E8',
            ...nodeStyle
          },
          name: 'startNodeShape'
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        if (name === 'show-anchor') {
          if (value) {
            const bbox = group.get('children')[0].getBBox()
            const anchorGroup = group.addGroup()
            this.getAnchorPoints().forEach((point, index) => {
              anchorGroup.addShape('circle', {
                attrs: {
                  stroke: '#1890FF',
                  fill: '#fff',
                  x: bbox.minX + bbox.width * point[0],
                  y: bbox.minY + bbox.height * point[1],
                  r: 3.5,
                  lineAppendWidth: 12,
                  cursor: 'crosshair',
                  opacity: 1
                },
                index,
                draggable: true,
                name: 'anchor'
              })
            })
          } else {
            const anchors = group.getLast().findAll(item => item)
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getFirst()
          value
            ? shape.attr(
              {
                fill: '#fdd492',
                stroke: '#fba746',
              }
            )
            : shape.attr(
              {
                fill: '#FFF2E8',
                stroke: '#FFC069',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = group.getLast().getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('process', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('rect', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            x: - width / 2,
            y: - height / 2,
            stroke: '#1890FF',
            fill: '#E6F7FF',
            radius: 4,
            ...nodeStyle
          },
          name: 'processShape'
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        if (name === 'show-anchor') {
          if (value) {
            const bbox = group.get('children')[0].getBBox()
            const anchorGroup = group.addGroup()
            this.getAnchorPoints().forEach((point, index) => {
              anchorGroup.addShape('circle', {
                attrs: {
                  stroke: '#1890FF',
                  fill: '#fff',
                  x: bbox.minX + bbox.width * point[0],
                  y: bbox.minY + bbox.height * point[1],
                  r: 3.5,
                  lineAppendWidth: 12,
                  cursor: 'crosshair',
                  opacity: 1
                },
                index,
                name: 'anchor'
              })
            })
          } else {
            const anchors = group.getLast().findAll(item => item)
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#92d4fd',
                stroke: '#55b2fe',
              }
            )
            : shape.attr(
              {
                fill: '#E6F7FF',
                stroke: '#1890FF',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = group.getLast().getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('decision', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('polygon', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            points: [
              [0, - height / 2],
              [width / 2, 0],
              [0, height / 2],
              [-width / 2, 0]
            ],
            stroke: '#5CDBD3',
            fill: '#E6FFFB',
            ...nodeStyle
          },
          name: 'decisionShape'
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        if (name === 'show-anchor') {
          if (value) {
            const bbox = group.get('children')[0].getBBox()
            const anchorGroup = group.addGroup()
            this.getAnchorPoints().forEach((point, index) => {
              anchorGroup.addShape('circle', {
                attrs: {
                  stroke: '#1890FF',
                  fill: '#fff',
                  x: bbox.minX + bbox.width * point[0],
                  y: bbox.minY + bbox.height * point[1],
                  r: 3.5,
                  lineAppendWidth: 12,
                  cursor: 'crosshair',
                  opacity: 1
                },
                index,
                name: 'anchor'
              })
            })
          } else {
            const anchors = group.getLast().findAll(item => item)
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#89e6dd',
                stroke: '#58d7d1',
              }
            )
            : shape.attr(
              {
                fill: '#E6FFFB',
                stroke: '#5CDBD3',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = group.getLast().getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      }
    }, 'single-node')
    G6.registerNode('io', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('polygon', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            points: [
              [width / 4 - width / 2, - height / 2],
              [width - width / 2, - height / 2],
              [width - width / 4 - width / 2, height - height / 2],
              [- width / 2, height - height / 2]
            ],
            stroke: '#B4CC72',
            fill: '#F8FFE5',
            ...nodeStyle
          },
          name: 'ioShape'
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        if (name === 'show-anchor') {
          if (value) {
            const bbox = group.get('children')[0].getBBox()
            const anchorGroup = group.addGroup()
            this.getAnchorPoints().forEach((point, index) => {
              anchorGroup.addShape('circle', {
                attrs: {
                  stroke: '#1890FF',
                  fill: '#fff',
                  x: bbox.minX + bbox.width * point[0],
                  y: bbox.minY + bbox.height * point[1],
                  r: 3.5,
                  lineAppendWidth: 12,
                  cursor: 'crosshair',
                  opacity: 1
                },
                index,
                name: 'anchor'
              })
            })
          } else {
            const anchors = group.getLast().findAll(item => item)
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#c8e08a',
                stroke: '#b5d45f',
              }
            )
            : shape.attr(
              {
                fill: '#F8FFE5',
                stroke: '#B4CC72',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = group.getLast().getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('terminal', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('rect', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            x: - width / 2,
            y: - height / 2,
            stroke: '#B37FEB',
            fill: '#F9F0FF',
            radius: 24,
            ...nodeStyle
          },
          name: 'terminalShape'
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        if (name === 'show-anchor') {
          if (value) {
            const bbox = group.get('children')[0].getBBox()
            const anchorGroup = group.addGroup()
            this.getAnchorPoints().forEach((point, index) => {
              anchorGroup.addShape('circle', {
                attrs: {
                  stroke: '#1890FF',
                  fill: '#fff',
                  x: bbox.minX + bbox.width * point[0],
                  y: bbox.minY + bbox.height * point[1],
                  r: 3.5,
                  lineAppendWidth: 12,
                  cursor: 'crosshair',
                  opacity: 1
                },
                index,
                name: 'anchor'
              })
            })
          } else {
            const anchors = group.getLast().findAll(item => item)
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#d3aff5',
                stroke: '#a26ee3'
              }
            )
            : shape.attr(
              {
                fill: '#F9F0FF',
                stroke: '#B37FEB',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = group.getLast().getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerBehavior('clickSelected', {
      getEvents() {
        return {
          'node:click': 'onNodeClick',
          'canvas:click': 'onCanvasClick'
        }
      },
      onNodeClick(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        const selectedNodes = graph.findAllByState('node', 'selected')
        if (selectedNodes.length) {
          selectedNodes.forEach(node => {
            graph.clearItemStates(node, 'selected')
            graph.setItemState(node, 'show-anchor', false)
          })
        }
        if (!item.hasState('selected')) {
          item.setState('selected', true)
          setDetailPanel(item)
        }
        item.setState('show-anchor', true)
      },
      onCanvasClick(e) {
        const self = this
        const graph = self.graph
        const nodes = graph.getNodes()
        nodes.forEach(node => {
          if (node.hasState('selected')) {
            graph.clearItemStates(node, 'selected')
          }
          if (node.hasState('show-anchor')) {
            graph.clearItemStates(node, 'show-anchor')
          }
        })
        setDetailPanel('canvas')
      }
    })
    G6.registerBehavior('hoverNodeActived', {
      getEvents() {
        return {
          'node:mouseover': 'onMouseOver',
          'node:mouseleave': 'onMouseLeave',
        }
      },
      onMouseOver(e) {
        const { item } = e
        graph.setItemState(item, 'node-hover', true)
        if (!item.hasState('selected')) {
          item.setState('show-anchor', true)
        }
      },
      onMouseLeave(e) {
        const { item } = e
        graph.clearItemStates(item, 'node-hover', 'anchor-hover')
        if (!item.hasState('selected')) {
          item.setState('show-anchor', false)
        }
      }
    })
    G6.registerBehavior('hoverAnchorActived', {
      getEvents() {
        return {
          'node:mouseover': 'onMouseOver',
          'node:mouseout': 'onMouseOut'
        }
      },
      onMouseOver(e) {
        const self = this
        const graph = self.graph
        const { item } = e

        if (e.target.get('name') === 'anchor') {
          const index = e.target.get('index')
          graph.setItemState(item, 'anchor-hover', `${index}-hover`)
        }
      },
      onMouseOut(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        if (e.target.get('name') === 'anchor') {
          const index = e.target.get('index')
          graph.setItemState(item, 'anchor-hover', `${index}-leave`)
        }
      }
    })
    G6.registerBehavior('dragCanvasCursor', {
      getEvents() {
        return {
          'canvas:dragstart': 'onDragStart',
          'canvas:dragend': 'onDragEnd',
          'canvas:mousemove': 'onMouseMove'
        }
      },
      onMouseMove() {
        const self = this
        const graph = self.graph
        // 进入画布时，鼠标指针变为抓手
        graph.get('canvas').get('el').style.cursor = 'grab'
      },
      onDragStart() {
        const self = this
        const graph = self.graph
        // 拖拽画布时，鼠标指针变为拳头
        graph.get('canvas').get('el').style.cursor = 'grabbing'
      },
      onDragEnd() {
        const self = this
        const graph = self.graph
        // 鼠标释放时，还原鼠标指针
        graph.get('canvas').get('el').style.cursor = 'grab'
      }
    })
    G6.registerBehavior('dragPanelItemAddNode', {
      getDefaultCfg() {
        return {}
      },
      getEvents() {
        return {
          'canvas:mousemove': 'onMouseMove',
          'canvas:mouseup': 'onMouseUp',
          'canvas:mouseleave': 'onMouseLeave'
        }
      },
      onMouseMove(e) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          let delegateShape = graph.get('addDelegateShape')
          const addModel = graph.get('addModel')
          const { width, height } = addModel
          const point = graph.getPointByClient(e.x, e.y)
          const { x, y } = point
          if (!delegateShape) {
            const parent = graph.get('group')
            delegateShape = parent.addShape('rect', {
              attrs: {
                width: parseInt(width),
                height: parseInt(height),
                x: x - width / 2,
                y: y - height / 2,
                stroke: '#1890FF',
                fill: '#1890FF',
                fillOpacity: .08,
                lineDash: [4, 4],
                radius: 4,
                lineWidth: 1
              },
              name: 'delegateShape'
            })
            delegateShape.set('capture', false)
            graph.set('addDelegateShape', delegateShape)
          }
          delegateShape.attr({ x: x - width / 2, y: y - height / 2 })
          graph.paint()
          this.graph.emit('afternodedrag', delegateShape)
        }
      },
      onMouseUp(e) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          const point = graph.getPointByClient(e.clientX, e.clientY)
          self._addNode(point)
        }
      },
      onMouseLeave() {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          this._clearDelegate()
          graph.emit('afternodedragend')
        }
      },
      _addNode(point) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          const addModel = graph.get('addModel')
          const { type } = addModel
          const timestamp = new Date().getTime()
          const id = `${type}-${timestamp}`
          const { x, y } = point
          graph.addItem('node', {
            ...addModel,
            x,
            y,
            id
          }, true)
          this._clearDelegate()
          const selectedNodes = graph.findAllByState('node', 'selected')
          if (selectedNodes.length) {
            selectedNodes.forEach(node => {
              graph.clearItemStates(node, 'selected')
              // 清除状态并不会重绘，只会对现有属性进行更改
              graph.setItemState(node, 'show-anchor', false)
            })
          }
          graph.setItemState(id, 'show-anchor', true)
          graph.setItemState(id, 'selected', true)
          setDetailPanel(graph.findById(id))
        }
      },
      _clearDelegate() {
        const self = this
        const graph = self.graph
        const delegateShape = graph.get('addDelegateShape')
        if (delegateShape) {
          delegateShape.remove()
          graph.set('addDelegateShape', null)
          graph.paint()
        }
        graph.emit('afternodedragend')
      }
    })
    G6.registerBehavior('dragNode', {
      getEvents() {
        return {
          'node:dragstart': 'onDragStart',
          'node:drag': 'onDrag',
          'node:dragend': 'onDragEnd'
        }
      },
      onDragStart(e) {
        const self = this
        const graph = self.graph
        if (e.target.get('name') !== 'anchor') {
          const { item } = e
          if (!item.hasState('selected')) {
            item.clearStates('show-anchor')
          }
          const model = item.getModel()
          const { canvasX: x, canvasY: y } = e
          const { width, height, id } = model
          graph.addItem('node', {
            type: 'rect',
            x,
            y,
            style: {
              width: parseInt(width),
              height: parseInt(height),
              stroke: '#1890FF',
              fill: '#1890FF',
              fillOpacity: .08,
              lineDash: [4, 4],
              radius: 4,
              lineWidth: 1,
            },
            id: 'delegateShape',
          }, true)
        }
      },
      onDrag(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        if (e.target.get('name') !== 'anchor') {
          const { canvasX: x, canvasY: y, item } = e
          const delegateShape = graph.findById('delegateShape')
          let delegateCfg = {
            x,
            y
          }
          delegateShape.updatePosition(delegateCfg)
          const delegateContainer = delegateShape.getBBox()
          const { minX: delegateMinX, minY: delegateMinY, maxX: delegateMaxX, maxY: delegateMaxY, centerX: delegateCenterX, centerY: delegateCenterY } = delegateContainer
          const nodes = graph.findAll('node', (node) => {
            return node.get('id') !== 'delegateShape'
          })
          let xNearNode
          let yNearNode
          let xDistance
          let yDistance
          // find nearest node
          nodes.forEach(node => {
            const { minX: nodeMinX, minY: nodeMinY, maxX: nodeMaxX, maxY: nodeMaxY, centerX: nodeCenterX, centerY: nodeCenterY } = node.getBBox()
            if (!xDistance) {
              xDistance = Math.abs(delegateMinX - nodeMinX)
              xNearNode = node
            }
            if (!yDistance) {
              yDistance = Math.abs(delegateMinY - nodeMinY)
              yNearNode = node
            }
            if (Math.abs(delegateMinX - nodeMinX) < xDistance) {
              xDistance = Math.abs(delegateMinX - nodeMinX)
              xNearNode = node
            }
            if (Math.abs(delegateMinY - nodeMinY) < yDistance) {
              yDistance = Math.abs(delegateMinY - nodeMinY)
              yNearNode = node
            }
          })

          const { minX: xNearNodeMinX, minY: xNearNodeMinY, maxX: xNearNodeMaxX, maxY: xNearNodeMaxY, centerX: xNearNodeCenterX, centerY: xNearNodeCenterY } = xNearNode.getBBox()
          const { minX: yNearNodeMinX, minY: yNearNodeMinY, maxX: yNearNodeMaxX, maxY: yNearNodeMaxY, centerX: yNearNodeCenterX, centerY: yNearNodeCenterY } = yNearNode.getBBox()
          let verticalStartPoint
          let verticalEndPoint
          let horizontalStartPoint
          let horizontalEndPoint
          const verticalAlignLine = group.findById('verticle-align-line')
          const horizontalAlignLine = group.findById('horizontal-align-line')
          const tolerance = 3
          if (Math.abs(delegateMinX - xNearNodeMinX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMinX) - xNearNodeCenterX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateMinX - xNearNodeMaxX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateCenterX - Math.floor(xNearNodeMinX)) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateCenterX - xNearNodeCenterX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateCenterX - Math.floor(xNearNodeMaxX)) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateMaxX - xNearNodeMinX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMaxX) - xNearNodeCenterX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateMaxX - xNearNodeMaxX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMinY
              }
            }
          }

          if (Math.abs(delegateMinY - yNearNodeMinY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMinY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMinY) - yNearNodeCenterY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeCenterY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeCenterY
              }
            }
          }
          if (Math.abs(delegateMinY - yNearNodeMaxY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMaxY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMaxY
              }
            }
          }
          if (Math.abs(delegateCenterY - Math.floor(yNearNodeMinY)) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMinY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMinY
              }
            }
          }
          if (Math.abs(delegateCenterY - yNearNodeCenterY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeCenterY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeCenterY
              }
            }
          }
          if (Math.abs(delegateCenterY - Math.floor(yNearNodeMaxY)) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMaxY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMaxY
              }
            }
          }
          if (Math.abs(delegateMaxY - yNearNodeMinY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMinY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMaxY) - yNearNodeCenterY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeCenterY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeCenterY
              }
            }
          }
          if (Math.abs(delegateMaxY - yNearNodeMaxY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMaxY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMaxY
              }
            }
          }

          if (!verticalAlignLine) {
            group.addShape('path', {
              attrs: {
                path: [
                  ['M', xNearNodeCenterX, xNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                stroke: '#FA8C16',
                opacity: 0,
                lineWidth: 1
              },
              id: 'verticle-align-line'
            })
          } else {
            if (verticalStartPoint && verticalEndPoint) {
              verticalAlignLine.attr({
                path: [
                  ['M', verticalStartPoint.x, verticalStartPoint.y],
                  ['L', verticalEndPoint.x, verticalEndPoint.y]
                ],
                opacity: 0.8
              })
            } else {
              verticalAlignLine.attr({
                path: [
                  ['M', xNearNodeCenterX, xNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                opacity: 0
              })
            }
          }

          if (!horizontalAlignLine) {
            group.addShape('path', {
              attrs: {
                path: [
                  ['M', yNearNodeCenterX, yNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                stroke: '#FA8C16',
                opacity: 1,
                lineWidth: 1
              },
              id: 'horizontal-align-line'
            })
          } else {
            if (horizontalStartPoint && horizontalEndPoint) {
              horizontalAlignLine.attr({
                path: [
                  ['M', horizontalStartPoint.x, horizontalStartPoint.y],
                  ['L', horizontalEndPoint.x, horizontalEndPoint.y]
                ],
                opacity: 0.8
              })
            } else {
              horizontalAlignLine.attr({
                path: [
                  ['M', yNearNodeCenterX, yNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                opacity: 0
              })
            }
          }
        }
      },
      onDragEnd(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        if (e.target.get('name') !== 'anchor') {
          const verticalAlignLine = group.findById('verticle-align-line')
          const horizontalAlignLine = group.findById('horizontal-align-line')
          group.removeChild(verticalAlignLine)
          group.removeChild(horizontalAlignLine)
          const { canvasX: x, canvasY: y, item } = e
          const cfg = {
            x,
            y
          }
          const delegateShape = graph.findById('delegateShape')
          item.updatePosition(cfg)
          graph.removeItem(delegateShape)
        }
      }
    })
    G6.registerBehavior('dragPoint', {
      getEvents() {
        return {
          'node:dragstart': 'onDragStart',
          'node:drag': 'onDrag',
          'node:dragend': 'onDragEnd'
        }
      },
      onDragStart(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        if (e.target.get('name') === 'anchor') {
          const { canvasX: x, canvasY: y } = e
          group.addShape('path', {
            attrs: {
              path: [
                ['M', x, y],
                ['L', x, y]
              ],
              stroke: '#1890FF',
              lineWidth: 1,
              lineDash: [4, 4]
            },
            id: 'delegate-edge'
          })
        }
      },
      onDrag(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')
        if (e.target.get('name') === 'anchor') {
          const { canvasX: x, canvasY: y, item } = e
          const index = e.target.get('index')
          const { minX, minY, centerX, centerY, maxX, maxY } = item.getBBox()
          const anchors = [
            {
              x: centerX,
              y: minY
            },
            {
              x: maxX,
              y: centerY
            },
            {
              x: centerX,
              y: maxY
            },
            {
              x: minX,
              y: centerY
            }
          ]
          delegateEdge.attr({
            path: [
              ['M', anchors[index].x, anchors[index].y],
              ['L', x, y]
            ],
          })
        }
      },
      onDragEnd(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')
        if (e.target.get('name') === 'anchor') {
          group.removeChild(delegateEdge)
        }
      }
    })
    function updateNode(input, target) {
      input.addEventListener('change', e => {
        const label = e.target.value
        target.update({
          label
        })
        console.log(target)
      })
    }
    function setDetailPanel(item) {
      const detailPanelTitle = document.querySelector('#property-title')
      const propertyContainer = document.querySelector('.property')
      const row = document.createElement('div')
      row.className = 'row'
      const label = document.createElement('div')
      label.innerHTML = 'Label'
      label.className = 'label'
      row.appendChild(label)
      const input = document.createElement('input')
      input.className = 'input'
      row.appendChild(input)
      if (item === 'canvas') {
        detailPanelTitle.innerHTML = 'Canvas'
        if (propertyContainer.children.length) {
          propertyContainer.innerHTML = ''
        }
      } else {
        if (item.getType() === 'node') {
          const { label } = item.getModel()
          detailPanelTitle.innerHTML = 'Node'
          propertyContainer.innerHTML = ''
          propertyContainer.appendChild(row)
          input.value = label
          updateNode(input, item)
        }
      }
    }
    const graph = new G6.Graph({
      container: 'canvas',
      width: container.clientWidth - 480,
      height: container.clientHeight,
      modes: {
        default: [
          {
            type: 'drag-canvas'
          }
        ],
        edit: [
          'drag-canvas',
          'dragPanelItemAddNode',
          'dragNode',
          'dragCanvasCursor',
          'hoverAnchorActived',
          'hoverNodeActived',
          'clickSelected',
          'dragPoint'
        ]
      },
      plugins: [minimap]
    })

    graph.setMode('edit')
    graph.render()
  </script>
</body>

</html>