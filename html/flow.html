<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flow Editor</title>
  <style>
    html {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    * {
      box-sizing: border-box;
    }

    body {
      background: #F0F2F5;
      margin: 0;
      height: 100%;
      overflow: hidden;
      font-size: 14px;
    }

    .editor {
      margin: 24px;
      background: #fff;
      height: calc(100% - 48px);
    }

    .toolbar {
      height: 44px;
      background: #FAFAFA;
      box-shadow: 0 -1px 0 inset rgba(0, 0, 0, 0.08);
      ;
    }

    .container {
      display: flex;
      height: calc(100% - 44px);
    }

    .item-panel {
      width: 240px;
      box-shadow: -1px 0 0 inset rgba(0, 0, 0, 0.08);
      padding: 24px;
    }

    .items {
      margin: 0;
      padding: 0;
    }

    .items li.item {
      list-style: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 24px;
      cursor: pointer;
    }

    .items li.item:last-child {
      margin-bottom: 0;
    }

    .detail-panel {
      width: 240px;
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      padding: 10px 16px;
      background: #FAFAFA;
      box-shadow: 0 -1px 0 inset rgba(0, 0, 0, 0.08);
    }

    .property {
      flex: 1
    }

    .canvas {
      flex: 1;
      box-shadow: -1px 0 0 inset rgba(0, 0, 0, 0.08);
    }
  </style>
</head>

<body>
  <div class="editor">
    <div class="toolbar">

    </div>
    <div class="container">
      <div class="item-panel">
        <ul class="items">
          <li class="item" data-type="start" data-width="72" data-height="72" data-label="Start">
            <img src="../assets/flow/start.svg" alt="Start">
          </li>
          <li class="item" data-type="process" data-width="84" data-height="46" data-label="Process">
            <img src="../assets/flow/process.svg" alt="Process">
          </li>
          <li class="item" data-type="decision" data-width="82" data-height="74" data-label="Decision">
            <img src="../assets/flow/decision.svg" alt="Decision">
          </li>
          <li class="item" data-type="io" data-width="80" data-height="40" data-label="IO">
            <img src="../assets/flow/io.svg" alt="IO">
          </li>
          <li class="item" data-type="terminal" data-width="80" data-height="48" data-label="Terminal">
            <img src="../assets/flow/terminal.svg" alt="Terminal">
          </li>
        </ul>
      </div>
      <div class="canvas" id="canvas"></div>
      <div class="detail-panel">
        <div class="panel-header">Canvas</div>
        <div class="property"></div>
        <div class="panel-header">Minimap</div>
        <div class="minimap"></div>
      </div>
    </div>
  </div>
  <script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.6.1/dist/g6.min.js"></script>
  <script>
    const container = document.querySelector('.container')
    const items = document.querySelectorAll('.items .item')
    const img = new Image()
    img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'

    items.forEach(item => {
      const { type, width, height, label } = item.dataset
      const addModel = {
        type,
        width,
        height,
        label
      }
      item.addEventListener('dragstart', e => {
        e.dataTransfer.setDragImage(img, 0, 0)
        graph.set('addNodeDragging', true)
        graph.set('addModel', addModel);
      })
      item.addEventListener('drag', e => {
        graph.emit('canvas:mousemove', e);
      })
      item.addEventListener('dragend', e => {
        graph.emit('canvas:mouseup', e);
        graph.set('addNodeDragging', false);
        graph.set('addModel', null);
      })
    })
    const nodeStyle = {
      shadowOffsetX: 0,
      shadowOffsetY: 4,
      shadowBlur: 10,
      shadowColor: 'rgba(13, 26, 38, 0.1)',
      lineWidth: 1
    }
    const minimapContainer = document.querySelector('.minimap')
    const minimap = new G6.Minimap({
      size: [240, 200],
      container: minimapContainer
    })
    G6.registerNode('start', {
      drawShape(cfg, group) {
        const { width, height, x, y, label, id } = cfg
        const shape = group.addShape('circle', {
          attrs: {
            id,
            width,
            height,
            r: width / 2,
            stroke: '#FFC069',
            fill: '#FFF2E8',
            ...nodeStyle
          },
          name: 'startNodeShape'
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        if (name === 'show-anchor') {
          if (value) {
            const bbox = group.get('children')[0].getBBox()
            const anchorGroup = group.addGroup()
            this.getAnchorPoints().forEach((point, index) => {
              anchorGroup.addShape('circle', {
                attrs: {
                  stroke: '#1890FF',
                  fill: '#fff',
                  x: bbox.minX + bbox.width * point[0],
                  y: bbox.minY + bbox.height * point[1],
                  r: 3.5,
                  lineAppendWidth: 12,
                  cursor: 'crosshair',
                  opacity: 1
                },
                index,
                name: 'anchor'
              })
            })
          } else {
            const anchors = group.getLast().findAll(item => item)
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getFirst()
          value
            ? shape.attr(
              {
                fill: '#fdd492',
                stroke: '#fba746',
              }
            )
            : shape.attr(
              {
                fill: '#FFF2E8',
                stroke: '#FFC069',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = group.getLast().getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('process', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('rect', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            x: - width / 2,
            y: - height / 2,
            stroke: '#1890FF',
            fill: '#E6F7FF',
            radius: 4,
            ...nodeStyle
          },
          name: 'processShape'
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        if (name === 'show-anchor') {
          if (value) {
            const bbox = group.get('children')[0].getBBox()
            const anchorGroup = group.addGroup()
            this.getAnchorPoints().forEach((point, index) => {
              anchorGroup.addShape('circle', {
                attrs: {
                  stroke: '#1890FF',
                  fill: '#fff',
                  x: bbox.minX + bbox.width * point[0],
                  y: bbox.minY + bbox.height * point[1],
                  r: 3.5,
                  lineAppendWidth: 12,
                  cursor: 'crosshair',
                  opacity: 1
                },
                index,
                name: 'anchor'
              })
            })
          } else {
            const anchors = group.getLast().findAll(item => item)
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#92d4fd',
                stroke: '#55b2fe',
              }
            )
            : shape.attr(
              {
                fill: '#E6F7FF',
                stroke: '#1890FF',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = group.getLast().getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('decision', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('polygon', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            points: [
              [0, - height / 2],
              [width / 2, 0],
              [0, height / 2],
              [-width / 2, 0]
            ],
            stroke: '#5CDBD3',
            fill: '#E6FFFB',
            ...nodeStyle
          },
          name: 'decisionShape'
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        if (name === 'show-anchor') {
          if (value) {
            const bbox = group.get('children')[0].getBBox()
            const anchorGroup = group.addGroup()
            this.getAnchorPoints().forEach((point, index) => {
              anchorGroup.addShape('circle', {
                attrs: {
                  stroke: '#1890FF',
                  fill: '#fff',
                  x: bbox.minX + bbox.width * point[0],
                  y: bbox.minY + bbox.height * point[1],
                  r: 3.5,
                  lineAppendWidth: 12,
                  cursor: 'crosshair',
                  opacity: 1
                },
                index,
                name: 'anchor'
              })
            })
          } else {
            const anchors = group.getLast().findAll(item => item)
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#89e6dd',
                stroke: '#58d7d1',
              }
            )
            : shape.attr(
              {
                fill: '#E6FFFB',
                stroke: '#5CDBD3',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = group.getLast().getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      }
    }, 'single-node')
    G6.registerNode('io', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('polygon', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            points: [
              [width / 4 - width / 2, - height / 2],
              [width - width / 2, - height / 2],
              [width - width / 4 - width / 2, height - height / 2],
              [- width / 2, height - height / 2]
            ],
            stroke: '#B4CC72',
            fill: '#F8FFE5',
            ...nodeStyle
          },
          name: 'ioShape'
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        if (name === 'show-anchor') {
          if (value) {
            const bbox = group.get('children')[0].getBBox()
            const anchorGroup = group.addGroup()
            this.getAnchorPoints().forEach((point, index) => {
              anchorGroup.addShape('circle', {
                attrs: {
                  stroke: '#1890FF',
                  fill: '#fff',
                  x: bbox.minX + bbox.width * point[0],
                  y: bbox.minY + bbox.height * point[1],
                  r: 3.5,
                  lineAppendWidth: 12,
                  cursor: 'crosshair',
                  opacity: 1
                },
                index,
                name: 'anchor'
              })
            })
          } else {
            const anchors = group.getLast().findAll(item => item)
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#c8e08a',
                stroke: '#b5d45f',
              }
            )
            : shape.attr(
              {
                fill: '#F8FFE5',
                stroke: '#B4CC72',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = group.getLast().getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('terminal', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('rect', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            x: - width / 2,
            y: - height / 2,
            stroke: '#B37FEB',
            fill: '#F9F0FF',
            radius: 24,
            ...nodeStyle
          },
          name: 'terminalShape'
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        if (name === 'show-anchor') {
          if (value) {
            const bbox = group.get('children')[0].getBBox()
            const anchorGroup = group.addGroup()
            this.getAnchorPoints().forEach((point, index) => {
              anchorGroup.addShape('circle', {
                attrs: {
                  stroke: '#1890FF',
                  fill: '#fff',
                  x: bbox.minX + bbox.width * point[0],
                  y: bbox.minY + bbox.height * point[1],
                  r: 3.5,
                  lineAppendWidth: 12,
                  cursor: 'crosshair',
                  opacity: 1
                },
                index,
                name: 'anchor'
              })
            })
          } else {
            const anchors = group.getLast().findAll(item => item)
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#d3aff5',
                stroke: '#a26ee3'
              }
            )
            : shape.attr(
              {
                fill: '#F9F0FF',
                stroke: '#B37FEB',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = group.getLast().getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerBehavior('clickSelected', {
      getEvents() {
        return {
          'node:click': 'onNodeClick',
          'canvas:click': 'onCanvasClick'
        }
      },
      onNodeClick(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        const selectedNodes = graph.findAllByState('node', 'selected')
        if (selectedNodes.length) {
          selectedNodes.forEach(node => {
            graph.clearItemStates(node, 'selected')
            graph.setItemState(node, 'show-anchor', false)
          })
        }
        if (!item.hasState('selected')) {
          item.setState('selected', true)
        }
      },
      onCanvasClick(e) {
        const self = this
        const graph = self.graph
        const nodes = graph.findAllByState('node', 'selected')
        if (nodes.length) {
          nodes.forEach(node => {
            graph.clearItemStates(node, 'selected')
            // 清除状态并不会重绘，只会对现有属性进行更改
            graph.setItemState(node, 'show-anchor', false)
          })
        }
      }
    })
    G6.registerBehavior('hoverNodeActived', {
      getEvents() {
        return {
          'node:mouseover': 'onMouseOver',
          'node:mouseleave': 'onMouseLeave',
        }
      },
      onMouseOver(e) {
        const { item } = e
        graph.setItemState(item, 'node-hover', true)
        if (!item.hasState('selected')) {
          item.setState('show-anchor', true)
        }
      },
      onMouseLeave(e) {
        const { item } = e
        graph.clearItemStates(item, 'node-hover')
        if (!item.hasState('selected')) {
          item.setState('show-anchor', false)
        }
      }
    })
    G6.registerBehavior('hoverAnchorActived', {
      getEvents() {
        return {
          'node:mouseover': 'onMouseOver',
          'node:mouseout': 'onMouseOut'
        }
      },
      onMouseOver(e) {
        const self = this
        const graph = self.graph
        const { item } = e

        if (e.target.get('name') === 'anchor') {
          const index = e.target.get('index')
          graph.setItemState(item, 'anchor-hover', `${index}-hover`)
        }
      },
      onMouseOut(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        if (e.target.get('name') === 'anchor') {
          const index = e.target.get('index')
          graph.setItemState(item, 'anchor-hover', `${index}-leave`)
        }
      }
    })
    G6.registerBehavior('dragCanvasCursor', {
      getEvents() {
        return {
          'canvas:dragstart': 'onDragStart',
          'canvas:dragend': 'onDragEnd',
          'canvas:mousemove': 'onMouseMove'
        }
      },
      onMouseMove() {
        const self = this
        const graph = self.graph
        // 进入画布时，鼠标指针变为抓手
        graph.get('canvas').get('el').style.cursor = 'grab'
      },
      onDragStart() {
        const self = this
        const graph = self.graph
        // 拖拽画布时，鼠标指针变为拳头
        graph.get('canvas').get('el').style.cursor = 'grabbing'
      },
      onDragEnd() {
        const self = this
        const graph = self.graph
        // 鼠标释放时，还原鼠标指针
        graph.get('canvas').get('el').style.cursor = 'grab'
      }
    })
    G6.registerBehavior('dragPanelItemAddNode', {
      getDefaultCfg() {
        return {}
      },
      getEvents() {
        return {
          'canvas:mousemove': 'onMouseMove',
          'canvas:mouseup': 'onMouseUp',
          'canvas:mouseleave': 'onMouseLeave'
        }
      },
      onMouseMove(e) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          let delegateShape = graph.get('addDelegateShape')
          const addModel = graph.get('addModel')
          const { width, height } = addModel
          const point = graph.getPointByClient(e.x, e.y)
          const { x, y } = point
          if (!delegateShape) {
            const parent = graph.get('group')
            delegateShape = parent.addShape('rect', {
              attrs: {
                width: parseInt(width),
                height: parseInt(height),
                x: x - width / 2,
                y: y - height / 2,
                stroke: '#1890FF',
                fill: '#1890FF',
                fillOpacity: .08,
                lineDash: [4, 4],
                radius: 4,
                lineWidth: 1
              },
              name: 'delegateShape'
            })
            delegateShape.set('capture', false)
            graph.set('addDelegateShape', delegateShape)
          }
          delegateShape.attr({ x: x - width / 2, y: y - height / 2 })
          graph.paint()
          this.graph.emit('afternodedrag', delegateShape)
        }
      },
      onMouseUp(e) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          const point = graph.getPointByClient(e.clientX, e.clientY)
          self._addNode(point)
        }
      },
      onMouseLeave() {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          this._clearDelegate()
          graph.emit('afternodedragend')
        }
      },
      _addNode(point) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          const addModel = graph.get('addModel')
          const { type } = addModel
          const timestamp = new Date().getTime()
          const id = `${type}-${timestamp}`
          const { x, y } = point
          graph.addItem('node', {
            ...addModel,
            x,
            y,
            id
          })
          this._clearDelegate()
          const selectedNodes = graph.findAllByState('node', 'selected')
          if (selectedNodes.length) {
            selectedNodes.forEach(node => {
              graph.clearItemStates(node, 'selected')
              // 清除状态并不会重绘，只会对现有属性进行更改
              graph.setItemState(node, 'show-anchor', false)
            })
          }
          graph.setItemState(id, 'show-anchor', true)
          graph.setItemState(id, 'selected', true)
        }
      },
      _clearDelegate() {
        const self = this
        const graph = self.graph
        const delegateShape = graph.get('addDelegateShape')
        if (delegateShape) {
          delegateShape.remove()
          graph.set('addDelegateShape', null)
          graph.paint()
        }
        graph.emit('afternodedragend')
      }
    })
    G6.registerBehavior('dragNode', {
      getEvents() {
        return {
          'node:dragstart': 'onDragStart',
          'node:drag': 'onDrag',
          'node:dragend': 'onDragEnd'
        }
      },
      onDragStart(e) {
        console.log('drag-start', e)
        const self = this
        const graph = self.graph
        const { item } = e
        const model = item.getModel()
        const { canvasX: x, canvasY: y } = e
        const { width, height } = model
        graph.addItem('node', {
          type: 'rect',
          x,
          y,
          style: {
            width: parseInt(width),
            height: parseInt(height)
          }
        }, true)
      },
      onDrag(e) {
        console.log('drag', e)
      },
      onDragEnd(e) {
        console.log('drag-end', e)
      }
    })
    const graph = new G6.Graph({
      container: 'canvas',
      width: container.clientWidth - 480,
      height: container.clientHeight,
      modes: {
        default: [
          {
            type: 'drag-canvas'
          }
        ],
        edit: [
          'drag-canvas',
          'dragPanelItemAddNode',
          'dragNode',
          'dragCanvasCursor',
          'hoverAnchorActived',
          'hoverNodeActived',
          'clickSelected'
        ]
      },
      plugins: [minimap]
    })

    graph.setMode('edit')
    graph.render()
  </script>
</body>

</html>