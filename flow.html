<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flow Editor</title>
  <style>
    html {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    * {
      box-sizing: border-box;
    }

    body {
      background: #F0F2F5;
      margin: 0;
      height: 100%;
      overflow: hidden;
      font-size: 14px;
    }

    .editor {
      margin: 24px;
      background: #fff;
      height: calc(100% - 48px);
    }

    .toolbar {
      height: 44px;
      background: #FAFAFA;
      box-shadow: 0 -1px 0 inset rgba(0, 0, 0, 0.08);
      ;
    }

    .container {
      display: flex;
      height: calc(100% - 44px);
    }

    .item-panel {
      width: 240px;
      box-shadow: -1px 0 0 inset rgba(0, 0, 0, 0.08);
      padding: 24px;
    }

    .items {
      margin: 0;
      padding: 0;
    }

    .items li.item {
      list-style: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 24px;
      cursor: pointer;
    }

    .items li.item:last-child {
      margin-bottom: 0;
    }

    .detail-panel {
      width: 240px;
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      padding: 10px 16px;
      background: #FAFAFA;
      box-shadow: 0 -1px 0 inset rgba(0, 0, 0, 0.08);
    }

    .property {
      flex: 1;
      padding: 16px;
    }

    .property .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }

    .property .row .label {
      text-align: right;
      margin-right: 8px;
      width: 33.3%;
    }

    .property .row .input {
      font-variant: tabular-nums;
      width: 66.6%;
      padding: 4px 11px;
      border: 1px solid #d9d9d9;
      border-radius: 2px;
      line-height: 1.5715;
      color: rgba(0, 0, 0, .85);
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }

    .property .row .input:focus {
      border-color: #40a9ff;
      outline: 0;
      box-shadow: 0 0 0 2px rgba(24, 144, 255, .2);
    }

    .property .row .input:hover {
      border-color: #40a9ff;
    }

    .property .row option {
      padding: 5px 12px;
    }

    .property .row .label::after {
      content: ':'
    }

    .canvas {
      flex: 1;
      box-shadow: -1px 0 0 inset rgba(0, 0, 0, 0.08);
    }
  </style>
</head>

<body>
  <div class="editor">
    <div class="toolbar">

    </div>
    <div class="container">
      <div class="item-panel">
        <ul class="items">
          <li class="item" data-type="start" data-width="72" data-height="72" data-label="Start">
            <img src="assets/flow/start.svg" alt="Start">
          </li>
          <li class="item" data-type="process" data-width="84" data-height="46" data-label="Process">
            <img src="assets/flow/process.svg" alt="Process">
          </li>
          <li class="item" data-type="decision" data-width="82" data-height="74" data-label="Decision">
            <img src="assets/flow/decision.svg" alt="Decision">
          </li>
          <li class="item" data-type="io" data-width="80" data-height="40" data-label="IO">
            <img src="assets/flow/io.svg" alt="IO">
          </li>
          <li class="item" data-type="terminal" data-width="80" data-height="48" data-label="Terminal">
            <img src="assets/flow/terminal.svg" alt="Terminal">
          </li>
        </ul>
      </div>
      <div class="canvas" id="canvas"></div>
      <div class="detail-panel">
        <div class="panel-header" id="property-title">Canvas</div>
        <div class="property"></div>
        <div class="panel-header">Minimap</div>
        <div class="minimap"></div>
      </div>
    </div>
  </div>
  <script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.6.1/dist/g6.min.js"></script>
  <script>
    const container = document.querySelector('.container')
    const items = document.querySelectorAll('.items .item')
    const img = new Image()
    img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'

    items.forEach(item => {
      const { type, width, height, label } = item.dataset
      const addModel = {
        type,
        width,
        height,
        label
      }
      item.addEventListener('dragstart', e => {
        e.dataTransfer.setDragImage(img, 0, 0)
        graph.set('addNodeDragging', true)
        graph.set('addModel', addModel);
      })
      item.addEventListener('drag', e => {
        graph.emit('canvas:mousemove', e);
      })
      item.addEventListener('dragend', e => {
        graph.emit('canvas:mouseup', e);
        graph.set('addNodeDragging', false);
        graph.set('addModel', null);
      })
    })
    const nodeStyle = {
      shadowOffsetX: 0,
      shadowOffsetY: 4,
      shadowBlur: 10,
      shadowColor: 'rgba(13, 26, 38, 0.1)',
      lineWidth: 1
    }
    const minimapContainer = document.querySelector('.minimap')
    const minimap = new G6.Minimap({
      size: [240, 200],
      container: minimapContainer
    })
    G6.registerNode('start', {
      drawShape(cfg, group) {
        const { width, height, x, y, id } = cfg
        const shape = group.addShape('circle', {
          attrs: {
            id,
            width,
            height,
            r: width / 2,
            stroke: '#FFC069',
            fill: '#FFF2E8',
            ...nodeStyle
          },
          name: 'startNodeShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 0
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            capture: true,
            draggable: true,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getFirst()
          value
            ? shape.attr(
              {
                fill: '#fdd492',
                stroke: '#fba746',
              }
            )
            : shape.attr(
              {
                fill: '#FFF2E8',
                stroke: '#FFC069',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('process', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('rect', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            x: - width / 2,
            y: - height / 2,
            stroke: '#1890FF',
            fill: '#E6F7FF',
            radius: 4,
            ...nodeStyle
          },
          name: 'processShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 1
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#92d4fd',
                stroke: '#55b2fe',
              }
            )
            : shape.attr(
              {
                fill: '#E6F7FF',
                stroke: '#1890FF',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('decision', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('polygon', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            points: [
              [0, - height / 2],
              [width / 2, 0],
              [0, height / 2],
              [-width / 2, 0]
            ],
            stroke: '#5CDBD3',
            fill: '#E6FFFB',
            ...nodeStyle
          },
          name: 'decisionShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 1
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#89e6dd',
                stroke: '#58d7d1',
              }
            )
            : shape.attr(
              {
                fill: '#E6FFFB',
                stroke: '#5CDBD3',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      }
    }, 'single-node')
    G6.registerNode('io', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('polygon', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            points: [
              [width / 4 - width / 2, - height / 2],
              [width - width / 2, - height / 2],
              [width - width / 4 - width / 2, height - height / 2],
              [- width / 2, height - height / 2]
            ],
            stroke: '#B4CC72',
            fill: '#F8FFE5',
            ...nodeStyle
          },
          name: 'ioShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 1
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#c8e08a',
                stroke: '#b5d45f',
              }
            )
            : shape.attr(
              {
                fill: '#F8FFE5',
                stroke: '#B4CC72',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('terminal', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('rect', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            x: - width / 2,
            y: - height / 2,
            stroke: '#B37FEB',
            fill: '#F9F0FF',
            radius: 24,
            ...nodeStyle
          },
          name: 'terminalShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 1
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#d3aff5',
                stroke: '#a26ee3'
              }
            )
            : shape.attr(
              {
                fill: '#F9F0FF',
                stroke: '#B37FEB',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerBehavior('clickSelected', {
      getEvents() {
        return {
          'node:click': 'onNodeClick',
          'canvas:click': 'onCanvasClick',
          'edge:click': 'onEdgeClick'
        }
      },
      onNodeClick(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        const selectedNodes = graph.findAllByState('node', 'selected')
        if (selectedNodes.length) {
          selectedNodes.forEach(node => {
            graph.clearItemStates(node, 'selected')
            graph.setItemState(node, 'show-anchor', false)
          })
        }
        if (!item.hasState('selected')) {
          item.setState('selected', true)
          setDetailPanel(item)
        }
        item.setState('show-anchor', true)
      },
      onCanvasClick(e) {
        const self = this
        const graph = self.graph
        const nodes = graph.getNodes()
        const edges = graph.getEdges()
        nodes.forEach(node => {
          if (node.hasState('selected')) {
            graph.clearItemStates(node, 'selected')
          }
          if (node.hasState('show-anchor')) {
            graph.clearItemStates(node, 'show-anchor')
          }
        })
        const edgeCfg = {
          style: {
            lineWidth: 1
          }
        }
        edges.forEach(edge => {
          if (edge.hasState('selected')) {
            graph.clearItemStates(edge, 'selected')
            graph.updateItem(edge, edgeCfg)
          }
        })
        setDetailPanel('canvas')
      },
      onEdgeClick(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        if (!item.hasState('selected')) {
          item.setState('selected', true)
          const cfg = {
            style: {
              stroke: '#A3B1BF',
              lineWidth: 2,
              endArrow: {
                path: G6.Arrow.triangle(6, 8, 0),
                d: 0,
                fill: '#A3B1BF'
              }
            }
          }
          graph.updateItem(item, cfg)
          setDetailPanel(item)
        }
      }
    })
    G6.registerBehavior('hoverNodeActived', {
      getEvents() {
        return {
          'node:mouseover': 'onMouseOver',
          'node:mouseleave': 'onMouseLeave',
        }
      },
      onMouseOver(e) {
        const { item } = e
        graph.setItemState(item, 'node-hover', true)
        if (!item.hasState('selected')) {
          item.setState('show-anchor', true)
        }
      },
      onMouseLeave(e) {
        const { item } = e
        graph.clearItemStates(item, 'node-hover', 'anchor-hover')
        if (!item.hasState('selected')) {
          item.setState('show-anchor', false)
        }
      }
    })
    G6.registerBehavior('hoverAnchorActived', {
      getEvents() {
        return {
          'node:mouseover': 'onMouseOver',
          'node:mouseout': 'onMouseOut'
        }
      },
      onMouseOver(e) {
        const self = this
        const graph = self.graph
        const { item } = e

        if (e.target.get('name') === 'anchor') {
          const index = e.target.get('index')
          graph.setItemState(item, 'anchor-hover', `${index}-hover`)
        }
      },
      onMouseOut(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        if (e.target.get('name') === 'anchor') {
          const index = e.target.get('index')
          graph.setItemState(item, 'anchor-hover', `${index}-leave`)
        }
      }
    })
    G6.registerBehavior('dragCanvasCursor', {
      getEvents() {
        return {
          'canvas:dragstart': 'onDragStart',
          'canvas:dragend': 'onDragEnd',
          'canvas:mousemove': 'onMouseMove'
        }
      },
      onMouseMove() {
        const self = this
        const graph = self.graph
        // 进入画布时，鼠标指针变为抓手
        graph.get('canvas').get('el').style.cursor = 'grab'
      },
      onDragStart() {
        const self = this
        const graph = self.graph
        // 拖拽画布时，鼠标指针变为拳头
        graph.get('canvas').get('el').style.cursor = 'grabbing'
      },
      onDragEnd() {
        const self = this
        const graph = self.graph
        // 鼠标释放时，还原鼠标指针
        graph.get('canvas').get('el').style.cursor = 'grab'
      }
    })
    G6.registerBehavior('dragPanelItemAddNode', {
      getDefaultCfg() {
        return {}
      },
      getEvents() {
        return {
          'canvas:mousemove': 'onMouseMove',
          'canvas:mouseup': 'onMouseUp',
          'canvas:mouseleave': 'onMouseLeave'
        }
      },
      onMouseMove(e) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          let delegateShape = graph.get('addDelegateShape')
          const addModel = graph.get('addModel')
          const { width, height } = addModel
          const point = graph.getPointByClient(e.x, e.y)
          const { x, y } = point
          if (!delegateShape) {
            const parent = graph.get('group')
            delegateShape = parent.addShape('rect', {
              attrs: {
                width: parseInt(width),
                height: parseInt(height),
                x: x - width / 2,
                y: y - height / 2,
                stroke: '#1890FF',
                fill: '#1890FF',
                fillOpacity: .08,
                lineDash: [4, 4],
                radius: 4,
                lineWidth: 1
              },
              name: 'delegateShape'
            })
            delegateShape.set('capture', false)
            graph.set('addDelegateShape', delegateShape)
          }
          delegateShape.attr({ x: x - width / 2, y: y - height / 2 })
          graph.paint()
          this.graph.emit('afternodedrag', delegateShape)
        }
      },
      onMouseUp(e) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          const point = graph.getPointByClient(e.clientX, e.clientY)
          self._addNode(point)
        }
      },
      onMouseLeave() {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          this._clearDelegate()
          graph.emit('afternodedragend')
        }
      },
      _addNode(point) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          const addModel = graph.get('addModel')
          const { type } = addModel
          const timestamp = new Date().getTime()
          const id = `${type}-${timestamp}`
          const { x, y } = point
          graph.addItem('node', {
            ...addModel,
            x,
            y,
            id
          }, true)
          this._clearDelegate()
          const selectedNodes = graph.findAllByState('node', 'selected')
          if (selectedNodes.length) {
            selectedNodes.forEach(node => {
              graph.clearItemStates(node, 'selected')
              // 清除状态并不会重绘，只会对现有属性进行更改
              graph.setItemState(node, 'show-anchor', false)
            })
          }
          graph.setItemState(id, 'show-anchor', true)
          graph.setItemState(id, 'selected', true)
          setDetailPanel(graph.findById(id))
        }
      },
      _clearDelegate() {
        const self = this
        const graph = self.graph
        const delegateShape = graph.get('addDelegateShape')
        if (delegateShape) {
          delegateShape.remove()
          graph.set('addDelegateShape', null)
          graph.paint()
        }
        graph.emit('afternodedragend')
      }
    })
    G6.registerBehavior('dragNode', {
      getEvents() {
        return {
          'node:dragstart': 'onDragStart',
          'node:drag': 'onDrag',
          'node:dragend': 'onDragEnd'
        }
      },
      onDragStart(e) {
        const self = this
        const graph = self.graph
        if (e.target.get('name') !== 'anchor') {
          const { item } = e
          if (!item.hasState('selected')) {
            item.clearStates('show-anchor')
          }
          const model = item.getModel()
          const { canvasX: x, canvasY: y } = e
          const { width, height, id } = model
          graph.addItem('node', {
            type: 'rect',
            x,
            y,
            style: {
              width: parseInt(width),
              height: parseInt(height),
              stroke: '#1890FF',
              fill: '#1890FF',
              fillOpacity: .08,
              lineDash: [4, 4],
              radius: 4,
              lineWidth: 1,
            },
            id: 'delegateShape',
          }, true)
        }
      },
      onDrag(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        if (e.target.get('name') !== 'anchor') {
          const { canvasX: x, canvasY: y, item } = e
          const delegateShape = graph.findById('delegateShape')
          let delegateCfg = {
            x,
            y
          }
          delegateShape.updatePosition(delegateCfg)
          const delegateContainer = delegateShape.getBBox()
          const { minX: delegateMinX, minY: delegateMinY, maxX: delegateMaxX, maxY: delegateMaxY, centerX: delegateCenterX, centerY: delegateCenterY } = delegateContainer
          const nodes = graph.findAll('node', (node) => {
            return node.get('id') !== 'delegateShape'
          })
          let xNearNode
          let yNearNode
          let xDistance
          let yDistance
          // find nearest node
          nodes.forEach(node => {
            const { minX: nodeMinX, minY: nodeMinY, maxX: nodeMaxX, maxY: nodeMaxY, centerX: nodeCenterX, centerY: nodeCenterY } = node.getBBox()
            if (!xDistance) {
              xDistance = Math.abs(delegateMinX - nodeMinX)
              xNearNode = node
            }
            if (!yDistance) {
              yDistance = Math.abs(delegateMinY - nodeMinY)
              yNearNode = node
            }
            if (Math.abs(delegateMinX - nodeMinX) < xDistance) {
              xDistance = Math.abs(delegateMinX - nodeMinX)
              xNearNode = node
            }
            if (Math.abs(delegateMinY - nodeMinY) < yDistance) {
              yDistance = Math.abs(delegateMinY - nodeMinY)
              yNearNode = node
            }
          })

          const { minX: xNearNodeMinX, minY: xNearNodeMinY, maxX: xNearNodeMaxX, maxY: xNearNodeMaxY, centerX: xNearNodeCenterX, centerY: xNearNodeCenterY } = xNearNode.getBBox()
          const { minX: yNearNodeMinX, minY: yNearNodeMinY, maxX: yNearNodeMaxX, maxY: yNearNodeMaxY, centerX: yNearNodeCenterX, centerY: yNearNodeCenterY } = yNearNode.getBBox()
          let verticalStartPoint
          let verticalEndPoint
          let horizontalStartPoint
          let horizontalEndPoint
          const verticalAlignLine = group.findById('verticle-align-line')
          const horizontalAlignLine = group.findById('horizontal-align-line')
          const tolerance = 3
          if (Math.abs(delegateMinX - xNearNodeMinX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMinX) - xNearNodeCenterX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateMinX - xNearNodeMaxX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateCenterX - Math.floor(xNearNodeMinX)) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateCenterX - xNearNodeCenterX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateCenterX - Math.floor(xNearNodeMaxX)) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateMaxX - xNearNodeMinX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMaxX) - xNearNodeCenterX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateMaxX - xNearNodeMaxX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMinY
              }
            }
          }

          if (Math.abs(delegateMinY - yNearNodeMinY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMinY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMinY) - yNearNodeCenterY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeCenterY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeCenterY
              }
            }
          }
          if (Math.abs(delegateMinY - yNearNodeMaxY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMaxY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMaxY
              }
            }
          }
          if (Math.abs(delegateCenterY - Math.floor(yNearNodeMinY)) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMinY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMinY
              }
            }
          }
          if (Math.abs(delegateCenterY - yNearNodeCenterY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeCenterY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeCenterY
              }
            }
          }
          if (Math.abs(delegateCenterY - Math.floor(yNearNodeMaxY)) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMaxY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMaxY
              }
            }
          }
          if (Math.abs(delegateMaxY - yNearNodeMinY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMinY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMaxY) - yNearNodeCenterY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeCenterY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeCenterY
              }
            }
          }
          if (Math.abs(delegateMaxY - yNearNodeMaxY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMaxY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMaxY
              }
            }
          }

          if (!verticalAlignLine) {
            group.addShape('path', {
              attrs: {
                path: [
                  ['M', xNearNodeCenterX, xNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                stroke: '#FA8C16',
                opacity: 0,
                lineWidth: 1
              },
              id: 'verticle-align-line'
            })
          } else {
            if (verticalStartPoint && verticalEndPoint) {
              verticalAlignLine.attr({
                path: [
                  ['M', verticalStartPoint.x, verticalStartPoint.y],
                  ['L', verticalEndPoint.x, verticalEndPoint.y]
                ],
                opacity: 0.8
              })
            } else {
              verticalAlignLine.attr({
                path: [
                  ['M', xNearNodeCenterX, xNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                opacity: 0
              })
            }
          }

          if (!horizontalAlignLine) {
            group.addShape('path', {
              attrs: {
                path: [
                  ['M', yNearNodeCenterX, yNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                stroke: '#FA8C16',
                opacity: 1,
                lineWidth: 1
              },
              id: 'horizontal-align-line'
            })
          } else {
            if (horizontalStartPoint && horizontalEndPoint) {
              horizontalAlignLine.attr({
                path: [
                  ['M', horizontalStartPoint.x, horizontalStartPoint.y],
                  ['L', horizontalEndPoint.x, horizontalEndPoint.y]
                ],
                opacity: 0.8
              })
            } else {
              horizontalAlignLine.attr({
                path: [
                  ['M', yNearNodeCenterX, yNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                opacity: 0
              })
            }
          }
        }
      },
      onDragEnd(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        if (e.target.get('name') !== 'anchor') {
          const verticalAlignLine = group.findById('verticle-align-line')
          const horizontalAlignLine = group.findById('horizontal-align-line')
          group.removeChild(verticalAlignLine)
          group.removeChild(horizontalAlignLine)
          const { canvasX: x, canvasY: y, item } = e
          const cfg = {
            x,
            y
          }
          const delegateShape = graph.findById('delegateShape')
          item.updatePosition(cfg)
          graph.updateItem(item, {})
          graph.setItemState(item, 'selected', true)
          graph.setItemState(item, 'show-anchor', true)
          graph.removeItem(delegateShape)
          const edges = graph.getEdges()
          const edgeCfg = {
            style: {
              lineWidth: 1
            }
          }
          edges.forEach(edge => {
            if (edge.hasState('selected')) {
              graph.clearItemStates(edge, 'selected')
              graph.updateItem(edge, edgeCfg)
            }
          })
        }
      }
    })
    G6.registerBehavior('dragPoint', {
      getEvents() {
        return {
          'node:dragstart': 'onDragStart',
          'node:drag': 'onDrag',
          'node:dragend': 'onDragEnd',
          'node:dragenter': 'onDragEnter',
          'node:dragleave': 'onDragLeave',
          'node:drop': 'onDrop'
        }
      },
      onDragStart(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        if (e.target.get('name') === 'anchor') {
          const { canvasX: x, canvasY: y, item } = e
          group.addShape('path', {
            attrs: {
              path: [
                ['M', x, y],
                ['L', x, y]
              ],

              stroke: '#1890FF',
              lineWidth: 1,
              lineDash: [4, 4]
            },
            id: 'delegate-edge'
          })
          const index = e.target.get('index')
          const id = item.get('id')
          graph.set('sourceNode', {
            item,
            sourceAnchor: index
          })
          const nodes = graph.getNodes()
          nodes.forEach(node => {
            node.setState('show-anchor', true)
            node.setState('show-hotspots', `${id},${index},inactive`)
          })
        }
      },
      onDrag(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')

        if (e.target.get('name') === 'anchor') {
          const { canvasX: x, canvasY: y, item } = e
          const index = e.target.get('index')
          const { minX, minY, centerX, centerY, maxX, maxY } = item.getBBox()
          const anchors = [
            {
              x: centerX,
              y: minY
            },
            {
              x: maxX,
              y: centerY
            },
            {
              x: centerX,
              y: maxY
            },
            {
              x: minX,
              y: centerY
            }
          ]
          delegateEdge.attr({
            path: [
              ['M', anchors[index].x, anchors[index].y],
              ['L', x, y]
            ],
          })
        }
      },
      onDragEnd(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')
        if (e.target.get('name') === 'anchor') {
          const { item } = e
          const nodes = graph.getNodes()
          if (item.hasState('selected')) {
            graph.clearItemStates(item, 'selected')
          }
          group.removeChild(delegateEdge)
          nodes.forEach(node => {
            node.setState('show-anchor', false)
            node.setState('show-hotspots', 'all,all,clear')
          })
        }
      },
      onDragEnter(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')
        const index = e.target.get('index')
        const { item } = e
        if (e.target.get('name') === 'anchor-marker' || e.target.get('name') === 'anchor') {
          if (delegateEdge) {
            delegateEdge.set('zIndex', -1)
            group.sort()
          }
          item.setState('hotspot-hover', `${index}-hover`)
        }
      },
      onDragLeave(e) {
        const index = e.target.get('index')
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')
        const { item } = e
        if (e.target.get('name') === 'anchor-marker') {
          if (delegateEdge) {
            delegateEdge.set('zIndex', 1)
            group.sort()
          }
          item.setState('hotspot-hover', `${index}-leave`)
        }
      },
      onDrop(e) {
        const targetAnchor = e.target.get('index')
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const { item: target } = e
        const { item: source, sourceAnchor } = graph.get('sourceNode')
        const delegateEdge = group.findById('delegate-edge')
        if (delegateEdge) {
          group.removeChild(delegateEdge)
        }

        let curvePosition = [1 / 2, 1 / 2]
        let curveOffset = [-20, 20]
        let edgeType = 'cubic'
        if (sourceAnchor === 0 && targetAnchor === 0) {
          edgeType = 'cubic'
          curvePosition = [1 / 2, 1 / 2]
          curveOffset = [-20, 20]
        }
        if (sourceAnchor === 1 && targetAnchor === 3) {
          edgeType = 'cubic'
        }
        if (sourceAnchor === 2 && targetAnchor === 0) {
          edgeType = 'cubic'
        }
        if (sourceAnchor === 3 && targetAnchor === 1) {
          edgeType = 'cubic'
        }
        const timestamp = new Date().getTime()
        const id = `line-${timestamp}`
        graph.addItem('edge', {
          id,
          type: edgeType,
          source,
          target,
          sourceAnchor,
          targetAnchor,
          curvePosition,
          curveOffset,
          style: {
            stroke: '#A3B1BF',
            lineWidth: 1,
            lineAppendWidth: 8,
            endArrow: {
              path: G6.Arrow.triangle(6, 8, 0),
              d: 0,
              fill: '#A3B1BF',
            }
          },
        })
        const edgeGroup = graph.get('edgeGroup')
        edgeGroup.toFront()
      }
    })
    G6.registerBehavior('hoverEdgeActived', {
      getEvents() {
        return {
          'edge:mouseover': 'onMouseOver',
          'edge:mouseleave': 'onMouseLeave'
        }
      },
      onMouseOver(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        if (!item.hasState('selected')) {
          const cfg = {
            style: {
              stroke: '#1890FF',
              endArrow: {
                path: G6.Arrow.triangle(6, 8, 0),
                d: 0,
                fill: '#1890FF'
              }
            }
          }
          graph.updateItem(item, cfg)
        }
      },
      onMouseLeave(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        if (!item.hasState('selected')) {
          const cfg = {
            style: {
              stroke: '#A3B1BF',
              endArrow: {
                path: G6.Arrow.triangle(6, 8, 0),
                d: 0,
                fill: '#A3B1BF'
              }
            }
          }
          graph.updateItem(item, cfg)
        }
      }
    })
    function updateItem(element, type, target) {
      if (type === 'label') {
        element.addEventListener('change', e => {
          const label = e.target.value
          target.update({
            label
          })
        })
      }

      if (type === 'shape') {
        element.addEventListener('change', e => {
          const { value } = e.target
          let type
          let radius = 0
          if (value === 'Smooth') {
            type = 'cubic'
          }
          if (value === 'Polyline') {
            type = 'polyline'
          }
          if (value === 'Polyline Round') {
            type = 'polyline'
            radius = 5
          }
          // 由于未使用 state，style 更新则会覆盖原有的 style，已有属性需要重新指定
          target.update({
            type,
            style: {
              stroke: '#A3B1BF',
              lineWidth: 2,
              endArrow: {
                path: G6.Arrow.triangle(6, 8, 0),
                d: 0,
                fill: '#A3B1BF'
              },
              radius,
              offset: 14
            }
          })
        })
      }
    }
    function setDetailPanel(item) {
      const detailPanelTitle = document.querySelector('#property-title')
      const propertyContainer = document.querySelector('.property')

      const labelRow = document.createElement('div')
      labelRow.className = 'row'
      const labelLabel = document.createElement('div')
      labelLabel.innerHTML = 'Label'
      labelLabel.className = 'label'
      labelRow.appendChild(labelLabel)
      const labelInput = document.createElement('input')
      labelInput.className = 'input'
      labelRow.appendChild(labelInput)

      const shapeRow = document.createElement('div')
      shapeRow.className = 'row'
      const shapeLabel = document.createElement('div')
      shapeLabel.innerHTML = 'Shape'
      shapeLabel.className = 'label'
      shapeRow.appendChild(shapeLabel)
      const shapeSelect = document.createElement('select')
      shapeSelect.className = 'input'
      shapeRow.appendChild(shapeSelect)
      const shapeOptions = ['Smooth', 'Polyline', 'Polyline Round']
      shapeOptions.forEach((option, index) => {
        const op = document.createElement('option')
        op.value = option
        op.text = option
        shapeSelect.appendChild(op)
      })
      if (item === 'canvas') {
        detailPanelTitle.innerHTML = 'Canvas'
        if (propertyContainer.children.length) {
          propertyContainer.innerHTML = ''
        }
      } else {
        if (item.getType() === 'node') {
          const { label } = item.getModel()
          detailPanelTitle.innerHTML = 'Node'
          propertyContainer.innerHTML = ''
          propertyContainer.appendChild(labelRow)
          labelInput.value = label
          updateItem(labelInput, item)
        }
        if (item.getType() === 'edge') {
          let { label, type, style } = item.getModel()
          if (!label) {
            label = ''
          }
          labelInput.value = label
          let shape
          if (type === 'cubic') {
            shape = 'Smooth'
          }
          if (type === 'polyline') {
            shape = 'Polyline'
            if (style.radius > 0) {
              shape = 'Polyline Round'
            }
          }
          shapeSelect.value = shape
          propertyContainer.innerHTML = ''
          detailPanelTitle.innerHTML = 'Edge'
          propertyContainer.appendChild(labelRow)
          propertyContainer.appendChild(shapeRow)
          updateItem(labelInput, 'label', item)
          updateItem(shapeSelect, 'shape', item)
        }
      }
    }
    const graph = new G6.Graph({
      container: 'canvas',
      width: container.clientWidth - 480,
      height: container.clientHeight,
      modes: {
        default: [
          {
            type: 'drag-canvas'
          }
        ],
        edit: [
          'drag-canvas',
          'dragPanelItemAddNode',
          'dragNode',
          'dragCanvasCursor',
          'hoverAnchorActived',
          'hoverNodeActived',
          'clickSelected',
          'dragPoint',
          'hoverEdgeActived'
        ]
      },
      plugins: [minimap]
    })

    graph.setMode('edit')
    graph.render()
  </script>
</body>

</html>