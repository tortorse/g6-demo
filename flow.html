<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flow Editor</title>
  <style>
    html {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    * {
      box-sizing: border-box;
    }

    body {
      background: #F0F2F5;
      margin: 0;
      height: 100%;
      overflow: hidden;
      font-size: 14px;
    }

    .editor {
      margin: 24px;
      background: #fff;
      height: calc(100% - 48px);
    }

    .toolbar {
      height: 44px;
      background: #FAFAFA;
      box-shadow: 0 -1px 0 inset rgba(0, 0, 0, 0.08);
      ;
    }

    .container {
      display: flex;
      height: calc(100% - 44px);
    }

    .item-panel {
      width: 240px;
      box-shadow: -1px 0 0 inset rgba(0, 0, 0, 0.08);
      padding: 24px;
    }

    .items {
      margin: 0;
      padding: 0;
    }

    .items li.item {
      list-style: none;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 24px;
      cursor: pointer;
    }

    .items li.item:last-child {
      margin-bottom: 0;
    }

    .detail-panel {
      width: 240px;
      display: flex;
      flex-direction: column;
    }

    .panel-header {
      padding: 10px 16px;
      background: #FAFAFA;
      box-shadow: 0 -1px 0 inset rgba(0, 0, 0, 0.08);
    }

    .property {
      flex: 1;
      padding: 16px;
    }

    .property .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }

    .property .row .label {
      text-align: right;
      margin-right: 8px;
      width: 33.3%;
    }

    .property .row .input {
      font-variant: tabular-nums;
      width: 66.6%;
      padding: 4px 11px;
      border: 1px solid #d9d9d9;
      border-radius: 2px;
      line-height: 1.5715;
      color: rgba(0, 0, 0, .85);
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
    }

    .property .row .input:focus {
      border-color: #40a9ff;
      outline: 0;
      box-shadow: 0 0 0 2px rgba(24, 144, 255, .2);
    }

    .property .row .input:hover {
      border-color: #40a9ff;
    }

    .property .row option {
      padding: 5px 12px;
    }

    .property .row .label::after {
      content: ':'
    }

    .canvas {
      flex: 1;
      box-shadow: -1px 0 0 inset rgba(0, 0, 0, 0.08);
      position: relative;
    }

    .context-menu-container {
      overflow: hidden;
      background: #fff;
      border-radius: 4px;
      box-shadow: 0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05);
    }

    .context-menu {
      margin: 0;
      padding: 0;
    }

    .context-menu li {
      list-style: none;
      color: rgba(0, 0, 0, .65);
      padding: 5px 12px;
    }

    .context-menu li.disabled {
      color: rgba(0, 0, 0, .25)
    }

    .context-menu li span {
      cursor: default;
    }

    .context-menu li span:not(:last-child) {
      margin-right: 8px;
    }

    .context-menu li:hover {
      background: #f5f5f5;
    }

    .context-menu li svg {
      width: 14px;
      fill: rgba(0, 0, 0, .65)
    }

    .context-menu li.disabled svg {
      fill: rgba(0, 0, 0, .25)
    }
  </style>
</head>

<body>
  <div class="editor">
    <div class="toolbar">

    </div>
    <div class="container">
      <div class="item-panel">
        <ul class="items">
          <li class="item" data-type="start" data-width="72" data-height="72" data-label="Start">
            <img src="assets/flow/start.svg" alt="Start">
          </li>
          <li class="item" data-type="process" data-width="84" data-height="46" data-label="Process">
            <img src="assets/flow/process.svg" alt="Process">
          </li>
          <li class="item" data-type="decision" data-width="82" data-height="74" data-label="Decision">
            <img src="assets/flow/decision.svg" alt="Decision">
          </li>
          <li class="item" data-type="io" data-width="80" data-height="40" data-label="IO">
            <img src="assets/flow/io.svg" alt="IO">
          </li>
          <li class="item" data-type="terminal" data-width="80" data-height="48" data-label="Terminal">
            <img src="assets/flow/terminal.svg" alt="Terminal">
          </li>
        </ul>
      </div>
      <div class="canvas" id="canvas"></div>
      <div class="detail-panel">
        <div class="panel-header" id="property-title">Canvas</div>
        <div class="property"></div>
        <div class="panel-header">Minimap</div>
        <div class="minimap"></div>
      </div>
    </div>
  </div>
  <!-- <script src="https://gw.alipayobjects.com/os/antv/pkg/_antv.g6-3.6.1/dist/g6.min.js"></script> -->
  <script src="https://gw.alipayobjects.com/os/lib/antv/g6/3.7.3/dist/g6.min.js"></script>
  <script>
    const container = document.querySelector('.container')
    const items = document.querySelectorAll('.items .item')
    const img = new Image()
    img.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
    items.forEach(item => {
      const { type, width, height, label } = item.dataset
      const addModel = {
        type,
        width,
        height,
        label
      }
      item.addEventListener('dragstart', e => {
        e.dataTransfer.setDragImage(img, 0, 0)
        graph.set('addNodeDragging', true)
        graph.set('addModel', addModel);
      })
      item.addEventListener('drag', e => {
        graph.emit('canvas:mousemove', e);
      })
      item.addEventListener('dragend', e => {
        graph.emit('canvas:mouseup', e);
        graph.set('addNodeDragging', false);
        graph.set('addModel', null);
      })
    })

    // context menu dom
    const canvas = document.querySelector('#canvas')
    const menuContainer = document.createElement('div')
    menuContainer.setAttribute('style', 'position: absolute;display:none')
    menuContainer.className = 'context-menu-container'
    canvas.appendChild(menuContainer)

    const nodeStyle = {
      shadowOffsetX: 0,
      shadowOffsetY: 4,
      shadowBlur: 10,
      shadowColor: 'rgba(13, 26, 38, 0.1)',
      lineWidth: 1
    }
    const minimapContainer = document.querySelector('.minimap')
    const minimap = new G6.Minimap({
      size: [240, 200],
      container: minimapContainer
    })
    G6.registerNode('start', {
      drawShape(cfg, group) {
        const { width, height, x, y, id } = cfg
        const shape = group.addShape('circle', {
          attrs: {
            id,
            width,
            height,
            r: width / 2,
            stroke: '#FFC069',
            fill: '#FFF2E8',
            ...nodeStyle
          },
          name: 'startNodeShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 0
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            capture: true,
            draggable: true,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getFirst()
          value
            ? shape.attr(
              {
                fill: '#fdd492',
                stroke: '#fba746',
              }
            )
            : shape.attr(
              {
                fill: '#FFF2E8',
                stroke: '#FFC069',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('process', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('rect', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            x: - width / 2,
            y: - height / 2,
            stroke: '#1890FF',
            fill: '#E6F7FF',
            radius: 4,
            ...nodeStyle
          },
          name: 'processShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 1
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#92d4fd',
                stroke: '#55b2fe',
              }
            )
            : shape.attr(
              {
                fill: '#E6F7FF',
                stroke: '#1890FF',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('decision', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('polygon', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            points: [
              [0, - height / 2],
              [width / 2, 0],
              [0, height / 2],
              [-width / 2, 0]
            ],
            stroke: '#5CDBD3',
            fill: '#E6FFFB',
            ...nodeStyle
          },
          name: 'decisionShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 1
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#89e6dd',
                stroke: '#58d7d1',
              }
            )
            : shape.attr(
              {
                fill: '#E6FFFB',
                stroke: '#5CDBD3',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      }
    }, 'single-node')
    G6.registerNode('io', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('polygon', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            points: [
              [width / 4 - width / 2, - height / 2],
              [width - width / 2, - height / 2],
              [width - width / 4 - width / 2, height - height / 2],
              [- width / 2, height - height / 2]
            ],
            stroke: '#B4CC72',
            fill: '#F8FFE5',
            ...nodeStyle
          },
          name: 'ioShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 1
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#c8e08a',
                stroke: '#b5d45f',
              }
            )
            : shape.attr(
              {
                fill: '#F8FFE5',
                stroke: '#B4CC72',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerNode('terminal', {
      drawShape(cfg, group) {
        const { width, height, label, id } = cfg
        const shape = group.addShape('rect', {
          attrs: {
            id,
            width: parseInt(width),
            height: parseInt(height),
            x: - width / 2,
            y: - height / 2,
            stroke: '#B37FEB',
            fill: '#F9F0FF',
            radius: 24,
            ...nodeStyle
          },
          name: 'terminalShape'
        })
        const bbox = group.getBBox()
        const anchorGroup = group.addGroup({
          name: 'anchor-group',
          zIndex: 2
        })
        const markerGroup = group.addGroup({
          name: 'marker-group',
          zIndex: 1
        })
        this.getAnchorPoints().forEach((point, index) => {
          anchorGroup.addShape('circle', {
            attrs: {
              stroke: '#1890FF',
              fill: '#fff',
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 3.5,
              lineAppendWidth: 12,
              cursor: 'crosshair',
              opacity: 1
            },
            index,
            draggable: true,
            name: 'anchor'
          })
          markerGroup.addShape('marker', {
            attrs: {
              x: bbox.minX + bbox.width * point[0],
              y: bbox.minY + bbox.height * point[1],
              r: 12,
              symbol: 'circle',
              fill: '#1890FF',
              opacity: 0,
              cursor: 'crosshair'
            },
            index,
            name: 'anchor-marker'
          })
        })
        return shape
      },
      setState(name, value, node) {
        const group = node.getContainer()
        group.sort()
        const anchorGroup = group.find(g => {
          return g.get('name') === 'anchor-group'
        })
        const markerGroup = group.find(g => {
          return g.get('name') === 'marker-group'
        })
        const anchors = anchorGroup.findAll(anchor => {
          return anchor.get('name') === 'anchor'
        })
        const markers = markerGroup.findAll(marker => {
          return marker.get('name') === 'anchor-marker'
        })
        if (name === 'show-anchor') {
          if (value) {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 1 })
            })
          } else {
            anchors.forEach(anchor => {
              anchor.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'show-hotspots') {
          const param = value.split(',')
          const id = param[0]
          const index = param[1]
          const state = param[2]
          if (state === 'inactive') {
            markers.forEach(marker => {
              marker.attr({ opacity: 0.25 })
            })
            if (id === node.get('id')) {
              markers[index].attr({ opacity: 0 })
            }
          } else {
            markers.forEach(marker => {
              marker.attr({ opacity: 0 })
            })
          }
        }
        if (name === 'selected') {
          const shape = group.getChildByIndex(0)
          value
            ? shape.attr(
              {
                fill: '#d3aff5',
                stroke: '#a26ee3'
              }
            )
            : shape.attr(
              {
                fill: '#F9F0FF',
                stroke: '#B37FEB',
              }
            )
        }
        if (name === 'anchor-hover') {
          const index = value.split('-')[0]
          const state = value.split('-')[1]
          const anchor = anchorGroup.getChildByIndex(index)
          if (state === 'hover') {
            anchor.attr({
              fill: '#1890FF'
            })
          } else {
            anchor.attr({
              fill: '#fff'
            })
          }
        }
        if (name === 'hotspot-hover') {
          const param = value.split('-')
          const index = param[0]
          const state = param[1]
          const marker = markerGroup.getChildByIndex(index)
          if (state === 'hover') {
            marker.attr({
              r: 14
            })
          }
          if (state === 'leave') {
            marker.attr({
              r: 12
            })
          }
        }
        if (name === 'node-hover') {
          if (value) {
            // keyshape 转换鼠标指针
            group.getFirst().attr({ cursor: 'move' })
            // 文字转换鼠标指针
            group.getChildByIndex(1).attr({ cursor: 'move' })
          }
        }
      },
      getAnchorPoints() {
        return [
          [0.5, 0], // top
          [1, 0.5], // right
          [0.5, 1], // bottom
          [0, 0.5], // left
        ]
      },
    }, 'single-node')
    G6.registerBehavior('clickSelected', {
      getEvents() {
        return {
          'node:click': 'onNodeClick',
          'canvas:click': 'onCanvasClick',
          'edge:click': 'onEdgeClick'
        }
      },
      onNodeClick(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        const selectedNodes = graph.findAllByState('node', 'selected')
        if (selectedNodes.length) {
          selectedNodes.forEach(node => {
            graph.clearItemStates(node, 'selected')
            graph.setItemState(node, 'show-anchor', false)
          })
        }
        if (!item.hasState('selected')) {
          item.setState('selected', true)
          setDetailPanel(item)
        }
        item.setState('show-anchor', true)
        const edges = graph.getEdges()
        const edgeCfg = {
          style: {
            lineWidth: 1
          }
        }
        edges.forEach(edge => {
          if (edge.hasState('selected')) {
            graph.clearItemStates(edge, 'selected')
            graph.updateItem(edge, edgeCfg, false)
          }
        })
      },
      onCanvasClick(e) {
        const self = this
        const graph = self.graph
        const nodes = graph.getNodes()
        const edges = graph.getEdges()
        nodes.forEach(node => {
          if (node.hasState('selected')) {
            graph.clearItemStates(node, 'selected')
          }
          if (node.hasState('show-anchor')) {
            graph.clearItemStates(node, 'show-anchor')
          }
        })
        const edgeCfg = {
          style: {
            lineWidth: 1
          }
        }
        edges.forEach(edge => {
          if (edge.hasState('selected')) {
            graph.clearItemStates(edge, 'selected')
            graph.updateItem(edge, edgeCfg, false)
          }
        })
        setDetailPanel('canvas')
      },
      onEdgeClick(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        const selectedEdges = graph.findAllByState('edge', 'selected')
        if (selectedEdges.length) {
          selectedEdges.forEach(edge => {
            graph.clearItemStates(edge, 'selected')
            const edgeCfg = {
              style: {
                lineWidth: 1
              }
            }
            graph.updateItem(edge, edgeCfg, false)
          })
        }
        if (!item.hasState('selected')) {
          item.setState('selected', true)
          const cfg = {
            style: {
              stroke: '#A3B1BF',
              lineWidth: 2,
              endArrow: {
                path: G6.Arrow.triangle(6, 8, 0),
                d: 0,
                fill: '#A3B1BF'
              }
            }
          }
          graph.updateItem(item, cfg, false)
          setDetailPanel(item)
          const nodes = graph.getNodes()
          nodes.forEach(node => {
            if (node.hasState('selected')) {
              graph.clearItemStates(node, 'selected')
            }
            if (node.hasState('show-anchor')) {
              graph.clearItemStates(node, 'show-anchor')
            }
          })
        }
      }
    })
    G6.registerBehavior('hoverNodeActived', {
      getEvents() {
        return {
          'node:mouseover': 'onMouseOver',
          'node:mouseleave': 'onMouseLeave',
        }
      },
      onMouseOver(e) {
        const { item } = e
        graph.setItemState(item, 'node-hover', true)
        if (!item.hasState('selected')) {
          item.setState('show-anchor', true)
        }
      },
      onMouseLeave(e) {
        const { item } = e
        graph.clearItemStates(item, 'node-hover', 'anchor-hover')
        if (!item.hasState('selected')) {
          item.setState('show-anchor', false)
        }
      }
    })
    G6.registerBehavior('hoverAnchorActived', {
      getEvents() {
        return {
          'node:mouseover': 'onMouseOver',
          'node:mouseout': 'onMouseOut'
        }
      },
      onMouseOver(e) {
        const self = this
        const graph = self.graph
        const { item } = e

        if (e.target.get('name') === 'anchor') {
          const index = e.target.get('index')
          graph.setItemState(item, 'anchor-hover', `${index}-hover`)
        }
      },
      onMouseOut(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        if (e.target.get('name') === 'anchor') {
          const index = e.target.get('index')
          graph.setItemState(item, 'anchor-hover', `${index}-leave`)
        }
      }
    })
    G6.registerBehavior('dragCanvasCursor', {
      getEvents() {
        return {
          'canvas:dragstart': 'onDragStart',
          'canvas:dragend': 'onDragEnd',
          'canvas:mousemove': 'onMouseMove'
        }
      },
      onMouseMove() {
        const self = this
        const graph = self.graph
        // 进入画布时，鼠标指针变为抓手
        graph.get('canvas').get('el').style.cursor = 'grab'
      },
      onDragStart() {
        const self = this
        const graph = self.graph
        // 拖拽画布时，鼠标指针变为拳头
        graph.get('canvas').get('el').style.cursor = 'grabbing'
      },
      onDragEnd() {
        const self = this
        const graph = self.graph
        // 鼠标释放时，还原鼠标指针
        graph.get('canvas').get('el').style.cursor = 'grab'
      }
    })
    G6.registerBehavior('dragPanelItemAddNode', {
      getEvents() {
        return {
          'canvas:mousemove': 'onMouseMove',
          'canvas:mouseup': 'onMouseUp',
          'canvas:mouseleave': 'onMouseLeave'
        }
      },
      onMouseMove(e) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          let delegateShape = graph.get('addDelegateShape')
          const addModel = graph.get('addModel')
          const { width, height } = addModel
          const point = graph.getPointByClient(e.x, e.y)
          const { x, y } = point
          if (!delegateShape) {
            const parent = graph.get('group')
            delegateShape = parent.addShape('rect', {
              attrs: {
                width: parseInt(width),
                height: parseInt(height),
                x: x - width / 2,
                y: y - height / 2,
                stroke: '#1890FF',
                fill: '#1890FF',
                fillOpacity: .08,
                lineDash: [4, 4],
                radius: 4,
                lineWidth: 1
              },
              name: 'delegateShape'
            })
            delegateShape.set('capture', false)
            graph.set('addDelegateShape', delegateShape)
          }
          delegateShape.attr({ x: x - width / 2, y: y - height / 2 })
          graph.paint()
          this.graph.emit('afternodedrag', delegateShape)
        }
      },
      onMouseUp(e) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          const point = graph.getPointByClient(e.clientX, e.clientY)
          self._addNode(point)
        }
      },
      onMouseLeave() {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          this._clearDelegate()
          graph.emit('afternodedragend')
        }
      },
      _addNode(point) {
        const self = this
        const graph = self.graph
        if (graph.get('addNodeDragging')) {
          const addModel = graph.get('addModel')
          const { type } = addModel
          const timestamp = new Date().getTime()
          const id = `${type}-${timestamp}`
          const { x, y } = point
          graph.addItem('node', {
            ...addModel,
            x,
            y,
            id
          }, true)
          this._clearDelegate()
          const selectedNodes = graph.findAllByState('node', 'selected')
          if (selectedNodes.length) {
            selectedNodes.forEach(node => {
              graph.clearItemStates(node, 'selected')
              // 清除状态并不会重绘，只会对现有属性进行更改
              graph.setItemState(node, 'show-anchor', false)
            })
          }
          graph.setItemState(id, 'show-anchor', true)
          graph.setItemState(id, 'selected', true)
          setDetailPanel(graph.findById(id))
        }
      },
      _clearDelegate() {
        const self = this
        const graph = self.graph
        const delegateShape = graph.get('addDelegateShape')
        if (delegateShape) {
          delegateShape.remove()
          graph.set('addDelegateShape', null)
          graph.paint()
        }
        graph.emit('afternodedragend')
      }
    })
    G6.registerBehavior('dragNode', {
      getEvents() {
        return {
          'node:dragstart': 'onDragStart',
          'node:drag': 'onDrag',
          'node:dragend': 'onDragEnd'
        }
      },
      onDragStart(e) {
        const self = this
        const graph = self.graph
        if (e.target.get('name') !== 'anchor') {
          const { item } = e
          if (!item.hasState('selected')) {
            item.clearStates('show-anchor')
          }
          const model = item.getModel()
          const { canvasX: x, canvasY: y } = e
          const { width, height, id } = model
          graph.addItem('node', {
            type: 'rect',
            x,
            y,
            style: {
              width: parseInt(width),
              height: parseInt(height),
              stroke: '#1890FF',
              fill: '#1890FF',
              fillOpacity: .08,
              lineDash: [4, 4],
              radius: 4,
              lineWidth: 1,
            },
            id: 'delegateShape',
          }, false)
        }
      },
      onDrag(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        if (e.target.get('name') !== 'anchor') {
          const { canvasX: x, canvasY: y, item } = e
          const delegateShape = graph.findById('delegateShape')
          let delegateCfg = {
            x,
            y
          }
          delegateShape.updatePosition(delegateCfg)
          const delegateContainer = delegateShape.getBBox()
          const { minX: delegateMinX, minY: delegateMinY, maxX: delegateMaxX, maxY: delegateMaxY, centerX: delegateCenterX, centerY: delegateCenterY } = delegateContainer
          const nodes = graph.findAll('node', (node) => {
            return node.get('id') !== 'delegateShape'
          })
          let xNearNode
          let yNearNode
          let xDistance
          let yDistance
          // find nearest node
          nodes.forEach(node => {
            const { minX: nodeMinX, minY: nodeMinY, maxX: nodeMaxX, maxY: nodeMaxY, centerX: nodeCenterX, centerY: nodeCenterY } = node.getBBox()
            if (!xDistance) {
              xDistance = Math.abs(delegateMinX - nodeMinX)
              xNearNode = node
            }
            if (!yDistance) {
              yDistance = Math.abs(delegateMinY - nodeMinY)
              yNearNode = node
            }
            if (Math.abs(delegateMinX - nodeMinX) < xDistance) {
              xDistance = Math.abs(delegateMinX - nodeMinX)
              xNearNode = node
            }
            if (Math.abs(delegateMinY - nodeMinY) < yDistance) {
              yDistance = Math.abs(delegateMinY - nodeMinY)
              yNearNode = node
            }
          })

          const { minX: xNearNodeMinX, minY: xNearNodeMinY, maxX: xNearNodeMaxX, maxY: xNearNodeMaxY, centerX: xNearNodeCenterX, centerY: xNearNodeCenterY } = xNearNode.getBBox()
          const { minX: yNearNodeMinX, minY: yNearNodeMinY, maxX: yNearNodeMaxX, maxY: yNearNodeMaxY, centerX: yNearNodeCenterX, centerY: yNearNodeCenterY } = yNearNode.getBBox()
          let verticalStartPoint
          let verticalEndPoint
          let horizontalStartPoint
          let horizontalEndPoint
          const verticalAlignLine = group.findById('verticle-align-line')
          const horizontalAlignLine = group.findById('horizontal-align-line')
          const tolerance = 3
          if (Math.abs(delegateMinX - xNearNodeMinX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMinX) - xNearNodeCenterX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateMinX - xNearNodeMaxX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateCenterX - Math.floor(xNearNodeMinX)) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateCenterX - xNearNodeCenterX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateCenterX - Math.floor(xNearNodeMaxX)) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateMaxX - xNearNodeMinX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMinX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMinX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMaxX) - xNearNodeCenterX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeCenterX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeCenterX,
                y: delegateMinY
              }
            }
          }
          if (Math.abs(delegateMaxX - xNearNodeMaxX) < tolerance) {
            if (delegateCenterY > xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMinY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMaxY
              }
            }
            if (delegateCenterY < xNearNodeCenterY) {
              verticalStartPoint = {
                x: xNearNodeMaxX,
                y: xNearNodeMaxY
              }
              verticalEndPoint = {
                x: xNearNodeMaxX,
                y: delegateMinY
              }
            }
          }

          if (Math.abs(delegateMinY - yNearNodeMinY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMinY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMinY) - yNearNodeCenterY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeCenterY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeCenterY
              }
            }
          }
          if (Math.abs(delegateMinY - yNearNodeMaxY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMaxY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMaxY
              }
            }
          }
          if (Math.abs(delegateCenterY - Math.floor(yNearNodeMinY)) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMinY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMinY
              }
            }
          }
          if (Math.abs(delegateCenterY - yNearNodeCenterY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeCenterY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeCenterY
              }
            }
          }
          if (Math.abs(delegateCenterY - Math.floor(yNearNodeMaxY)) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMaxY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMaxY
              }
            }
          }
          if (Math.abs(delegateMaxY - yNearNodeMinY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMinY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMinY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMinY
              }
            }
          }
          if (Math.abs(Math.floor(delegateMaxY) - yNearNodeCenterY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeCenterY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeCenterY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeCenterY
              }
            }
          }
          if (Math.abs(delegateMaxY - yNearNodeMaxY) < tolerance) {
            if (delegateCenterX > yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMinX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMaxX,
                y: yNearNodeMaxY
              }
            }
            if (delegateCenterX < yNearNodeCenterX) {
              horizontalStartPoint = {
                x: yNearNodeMaxX,
                y: yNearNodeMaxY
              }
              horizontalEndPoint = {
                x: delegateMinX,
                y: yNearNodeMaxY
              }
            }
          }

          if (!verticalAlignLine) {
            group.addShape('path', {
              attrs: {
                path: [
                  ['M', xNearNodeCenterX, xNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                stroke: '#FA8C16',
                opacity: 0,
                lineWidth: 1
              },
              id: 'verticle-align-line'
            })
          } else {
            if (verticalStartPoint && verticalEndPoint) {
              verticalAlignLine.attr({
                path: [
                  ['M', verticalStartPoint.x, verticalStartPoint.y],
                  ['L', verticalEndPoint.x, verticalEndPoint.y]
                ],
                opacity: 0.8
              })
            } else {
              verticalAlignLine.attr({
                path: [
                  ['M', xNearNodeCenterX, xNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                opacity: 0
              })
            }
          }

          if (!horizontalAlignLine) {
            group.addShape('path', {
              attrs: {
                path: [
                  ['M', yNearNodeCenterX, yNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                stroke: '#FA8C16',
                opacity: 1,
                lineWidth: 1
              },
              id: 'horizontal-align-line'
            })
          } else {
            if (horizontalStartPoint && horizontalEndPoint) {
              horizontalAlignLine.attr({
                path: [
                  ['M', horizontalStartPoint.x, horizontalStartPoint.y],
                  ['L', horizontalEndPoint.x, horizontalEndPoint.y]
                ],
                opacity: 0.8
              })
            } else {
              horizontalAlignLine.attr({
                path: [
                  ['M', yNearNodeCenterX, yNearNodeCenterY],
                  ['L', delegateCenterX, delegateCenterY]
                ],
                opacity: 0
              })
            }
          }
        }
      },
      onDragEnd(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        if (e.target.get('name') !== 'anchor') {
          const verticalAlignLine = group.findById('verticle-align-line')
          const horizontalAlignLine = group.findById('horizontal-align-line')
          group.removeChild(verticalAlignLine)
          group.removeChild(horizontalAlignLine)
          const { canvasX: x, canvasY: y, item } = e
          const cfg = {
            x,
            y
          }
          const delegateShape = graph.findById('delegateShape')
          graph.updateItem(item, cfg, true)

          const selectedNodes = graph.findAllByState('node', 'selected')
          selectedNodes.forEach(node => {
            graph.clearItemStates(node, 'selected')
          })
          graph.setItemState(item, 'selected', true)
          graph.setItemState(item, 'show-anchor', true)
          graph.removeItem(delegateShape, false)
          const edges = graph.getEdges()
          const edgeCfg = {
            style: {
              lineWidth: 1
            }
          }
          edges.forEach(edge => {
            if (edge.hasState('selected')) {
              graph.clearItemStates(edge, 'selected')
              graph.updateItem(edge, edgeCfg)
            }
          })
        }
      }
    })
    G6.registerBehavior('dragPoint', {
      getEvents() {
        return {
          'node:dragstart': 'onDragStart',
          'node:drag': 'onDrag',
          'node:dragend': 'onDragEnd',
          'node:dragenter': 'onDragEnter',
          'node:dragleave': 'onDragLeave',
          'node:drop': 'onDrop'
        }
      },
      onDragStart(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        if (e.target.get('name') === 'anchor') {
          const { canvasX: x, canvasY: y, item } = e
          group.addShape('path', {
            attrs: {
              path: [
                ['M', x, y],
                ['L', x, y]
              ],

              stroke: '#1890FF',
              lineWidth: 1,
              lineDash: [4, 4]
            },
            id: 'delegate-edge'
          })
          const index = e.target.get('index')
          const id = item.get('id')
          graph.set('sourceNode', {
            item,
            sourceAnchor: index
          })
          const nodes = graph.getNodes()
          nodes.forEach(node => {
            node.setState('show-anchor', true)
            node.setState('show-hotspots', `${id},${index},inactive`)
          })
        }
      },
      onDrag(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')

        if (e.target.get('name') === 'anchor') {
          const { canvasX: x, canvasY: y, item } = e
          const index = e.target.get('index')
          const { minX, minY, centerX, centerY, maxX, maxY } = item.getBBox()
          const anchors = [
            {
              x: centerX,
              y: minY
            },
            {
              x: maxX,
              y: centerY
            },
            {
              x: centerX,
              y: maxY
            },
            {
              x: minX,
              y: centerY
            }
          ]
          delegateEdge.attr({
            path: [
              ['M', anchors[index].x, anchors[index].y],
              ['L', x, y]
            ],
          })
        }
      },
      onDragEnd(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')
        if (e.target.get('name') === 'anchor') {
          const { item } = e
          const nodes = graph.getNodes()
          if (item.hasState('selected')) {
            graph.clearItemStates(item, 'selected')
          }
          group.removeChild(delegateEdge)
          nodes.forEach(node => {
            node.setState('show-anchor', false)
            node.setState('show-hotspots', 'all,all,clear')
          })
        }
      },
      onDragEnter(e) {
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')
        const index = e.target.get('index')
        const { item } = e
        if (e.target.get('name') === 'anchor-marker' || e.target.get('name') === 'anchor') {
          if (delegateEdge) {
            delegateEdge.set('zIndex', -1)
            group.sort()
          }
          item.setState('hotspot-hover', `${index}-hover`)
        }
      },
      onDragLeave(e) {
        const index = e.target.get('index')
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const delegateEdge = group.findById('delegate-edge')
        const { item } = e
        if (e.target.get('name') === 'anchor-marker') {
          if (delegateEdge) {
            delegateEdge.set('zIndex', 1)
            group.sort()
          }
          item.setState('hotspot-hover', `${index}-leave`)
        }
      },
      onDrop(e) {
        const targetAnchor = e.target.get('index')
        const self = this
        const graph = self.graph
        const group = graph.get('group')
        const { item: target } = e
        const { item: source, sourceAnchor } = graph.get('sourceNode')
        const delegateEdge = group.findById('delegate-edge')
        if (delegateEdge) {
          group.removeChild(delegateEdge)
        }

        let curvePosition = [1 / 2, 1 / 2]
        let curveOffset = [-20, 20]
        let edgeType = 'cubic'
        const timestamp = new Date().getTime()
        const id = `line-${timestamp}`
        graph.addItem('edge', {
          id,
          type: edgeType,
          source,
          target,
          sourceAnchor,
          targetAnchor,
          curvePosition,
          curveOffset,
          style: {
            stroke: '#A3B1BF',
            lineWidth: 1,
            lineAppendWidth: 8,
            endArrow: {
              path: G6.Arrow.triangle(6, 8, 0),
              d: 0,
              fill: '#A3B1BF',
            }
          },
        }, true)
        const edgeGroup = graph.get('edgeGroup')
        edgeGroup.toFront()
      }
    })
    G6.registerBehavior('hoverEdgeActived', {
      getEvents() {
        return {
          'edge:mouseover': 'onMouseOver',
          'edge:mouseleave': 'onMouseLeave'
        }
      },
      onMouseOver(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        if (!item.hasState('selected')) {
          const cfg = {
            style: {
              stroke: '#1890FF',
              endArrow: {
                path: G6.Arrow.triangle(6, 8, 0),
                d: 0,
                fill: '#1890FF'
              }
            }
          }
          graph.updateItem(item, cfg, false)
        }
      },
      onMouseLeave(e) {
        const self = this
        const graph = self.graph
        const { item } = e
        if (!item.hasState('selected')) {
          const cfg = {
            style: {
              stroke: '#A3B1BF',
              endArrow: {
                path: G6.Arrow.triangle(6, 8, 0),
                d: 0,
                fill: '#A3B1BF'
              }
            }
          }
          graph.updateItem(item, cfg, false)
        }
      }
    })
    G6.registerBehavior('deleteItem', {
      getEvents() {
        return {
          'keydown': 'onKeydown'
        }
      },
      onKeydown(e) {
        const self = this
        const graph = self.graph
        const nodes = graph.findAllByState('node', 'selected')
        const edges = graph.findAllByState('edge', 'selected')
        const { keyCode } = e
        if (keyCode === 46) {
          // 先删除edge，因为删除 node 的同时， edge 也不复存在，无法再次删除
          edges.forEach((edge) => {
            graph.removeItem(edge, true)
          })
          nodes.forEach((node) => {
            graph.removeItem(node, true)
          })
        }
      }
    })
    G6.registerBehavior('contextMenu', {
      getEvents() {
        return {
          'canvas:contextmenu': 'onCanvasContextMenu',
          'canvas:click': 'onCanvasClick',
          'node:contextmenu': 'onNodeContextMenu',
          'edge:contextmenu': 'onEdgeContextMenu'
        }
      },
      onCanvasContextMenu(e) {
        e.preventDefault()
        e.stopPropagation()
        const { canvasX, canvasY } = e
        showMenu('canvas', canvasX, canvasY)
        const menu = document.querySelector('.context-menu')
        const undoStack = graph.getUndoStack()
        const redoStack = graph.getRedoStack()
        const undoMenu = document.querySelector('li[data-command="undo"]')
        const redoMenu = document.querySelector('li[data-command="redo"]')
        const pasteHereMenu = document.querySelector('li[data-command="pasteHere"]')
        if (undoStack.length === 1) {
          undoMenu.classList.add('disabled')
          undoMenu.setAttribute('style', 'cursor: not-allowed')
        } else {
          undoMenu.classList.remove('disabled')
          undoMenu.removeAttribute('style')
        }
        if (redoStack.length === 0) {
          redoMenu.classList.add('disabled')
          redoMenu.setAttribute('style', 'cursor: not-allowed')
        } else {
          redoMenu.classList.remove('disabled')
          redoMenu.removeAttribute('style')
        }
        if (!clipboard) {
          pasteHereMenu.classList.add('disabled')
          pasteHereMenu.setAttribute('style', 'cursor: not-allowed')
        } else {
          pasteHereMenu.classList.remove('disabled')
          pasteHereMenu.removeAttribute('style')
        }
        let item
        menu.addEventListener('click', e => {
          if (e.target.matches('span')) {
            item = e.target.parentElement
          }
          if (e.target.matches('li')) {
            item = e.target
          }
          if (e.target.matches('svg')) {
            item = e.target.parentElement.parentElement
          }
          if (e.target.matches('path')) {
            item = e.target.parentElement.parentElement.parentElement
          }
          const { command } = item.dataset
          switch (command) {
            case 'undo':
              undo()
              break
            case 'redo':
              redo()
              break
            case 'pasteHere':
              if (clipboard) {
                paste(canvasX, canvasY)
              }
              break
          }
        })
      },
      onNodeContextMenu(e) {
        e.preventDefault()
        e.stopPropagation()
        const { canvasX, canvasY } = e
        showMenu('node', canvasX, canvasY)
        const menu = document.querySelector('.context-menu')
        let item
        let currentNode = e.item
        menu.addEventListener('click', e => {
          if (e.target.matches('span')) {
            item = e.target.parentElement
          }
          if (e.target.matches('li')) {
            item = e.target
          }
          if (e.target.matches('svg')) {
            item = e.target.parentElement.parentElement
          }
          if (e.target.matches('path')) {
            item = e.target.parentElement.parentElement.parentElement
          }
          const { command } = item.dataset
          switch (command) {
            case 'copy':
              copy(currentNode)
              break
            case 'delete':
              graph.removeItem(currentNode, true)
              menuContainer.setAttribute('style', `display:none`)
              break
            default:
          }
        })
      },
      onEdgeContextMenu(e) {
        e.preventDefault()
        e.stopPropagation()
        const { canvasX, canvasY } = e
        showMenu('edge', canvasX, canvasY)
        const menu = document.querySelector('.context-menu')
        let item
        let currentEdge = e.item
        menu.addEventListener('click', e => {
          if (e.target.matches('span')) {
            item = e.target.parentElement
          }
          if (e.target.matches('li')) {
            item = e.target
          }
          if (e.target.matches('svg')) {
            item = e.target.parentElement.parentElement
          }
          if (e.target.matches('path')) {
            item = e.target.parentElement.parentElement.parentElement
          }
          const { command } = item.dataset
          switch (command) {
            case 'delete':
              graph.removeItem(currentEdge, true)
              menuContainer.setAttribute('style', `display:none`)
              break
            default:
          }
        })
      },
      onCanvasClick(e) {
        menuContainer.setAttribute('style', `display:none`)
      }
    })
    /**
    * undo 操作
    */
    function undo() {
      const undoStack = graph.getUndoStack()
      if (!undoStack || undoStack.length === 1) {
        return
      }
      const currentData = undoStack.pop()
      if (currentData) {
        const { action } = currentData
        graph.pushStack(action, clone(currentData.data), 'redo')
        let data = currentData.data.before

        if (action === 'add') {
          data = currentData.data.after;
        }

        if (!data) return
        switch (action) {
          case 'visible': {
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                const item = graph.findById(model.id)
                if (model.visible) {
                  graph.showItem(item, false)
                } else {
                  graph.hideItem(item, false)
                }
              })
            })
            break
          }
          case 'render':
          case 'update':
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                graph.updateItem(model.id, model, false)
              })
            })
            break
          case 'changedata':
            graph.changeData(data, false)
            break
          case 'delete': {
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                const itemType = model.itemType
                delete model.itemType
                graph.addItem(itemType, model, false)
              })
            })
            break
          }
          case 'add':
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                graph.removeItem(model.id, false)
              })
            })
            break
          default:
        }
        menuContainer.setAttribute('style', `display:none`)
      }
    }
    /**
    * redo 操作
    */
    function redo() {
      const redoStack = graph.getRedoStack()
      if (!redoStack || redoStack.length === 0) {
        return
      }

      const currentData = redoStack.pop()
      if (currentData) {
        const { action } = currentData
        let data = currentData.data.after
        graph.pushStack(action, clone(currentData.data), 'undo')
        if (action === 'delete') {
          data = currentData.data.before;
        }

        if (!data) return
        switch (action) {
          case 'visible': {
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                const item = graph.findById(model.id)
                if (model.visible) {
                  graph.showItem(item, false)
                } else {
                  graph.hideItem(item, false)
                }
              })
            })
            break
          }
          case 'render':
          case 'update':
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                graph.updateItem(model.id, model, false)
              })
            })
            break
          case 'changedata':
            graph.changeData(data, false)
            break
          case 'delete':
            if (data.edges) {
              data.edges.forEach(model => {
                graph.removeItem(model.id, false)
              })
            }
            if (data.nodes) {
              data.nodes.forEach(model => {
                graph.removeItem(model.id, false)
              })
            }
            break
          case 'add': {
            Object.keys(data).forEach(key => {
              const array = data[key]
              if (!array) return
              array.forEach(model => {
                const itemType = model.itemType
                delete model.itemType
                graph.addItem(itemType, model, false)
              })
            })
          }
        }
        menuContainer.setAttribute('style', `display:none`)
      }
    }
    function updateItem(element, type, target) {
      if (type === 'label') {
        element.addEventListener('change', e => {
          const label = e.target.value
          const cfg = {
            label,
            labelCfg: {
              style: {
                background: {
                  fill: '#ffffff',
                  padding: [2, 2, 2, 2],
                }
              }
            }
          }
          /** 
          * node 的 label 无背景
          */
          if (target.get('type') === 'node') {
            delete cfg.labelCfg.style
          }
          graph.updateItem(target, cfg, true)
        })
      }

      if (type === 'shape') {
        element.addEventListener('change', e => {
          const { value } = e.target
          let type
          let radius = 0
          if (value === 'Smooth') {
            type = 'cubic'
          }
          if (value === 'Polyline') {
            type = 'polyline'
          }
          if (value === 'Polyline Round') {
            type = 'polyline'
            radius = 5
          }
          // 由于未使用 state，style 更新则会覆盖原有的 style，已有属性需要重新指定
          graph.updateItem(target, {
            type,
            style: {
              stroke: '#A3B1BF',
              lineWidth: 2,
              endArrow: {
                path: G6.Arrow.triangle(6, 8, 0),
                d: 0,
                fill: '#A3B1BF'
              },
              radius,
              offset: 14
            }
          }, true)
        })
      }
    }
    function setDetailPanel(item) {
      const detailPanelTitle = document.querySelector('#property-title')
      const propertyContainer = document.querySelector('.property')

      const labelRow = document.createElement('div')
      labelRow.className = 'row'
      const labelLabel = document.createElement('div')
      labelLabel.innerHTML = 'Label'
      labelLabel.className = 'label'
      labelRow.appendChild(labelLabel)
      const labelInput = document.createElement('input')
      labelInput.className = 'input'
      labelRow.appendChild(labelInput)

      const shapeRow = document.createElement('div')
      shapeRow.className = 'row'
      const shapeLabel = document.createElement('div')
      shapeLabel.innerHTML = 'Shape'
      shapeLabel.className = 'label'
      shapeRow.appendChild(shapeLabel)
      const shapeSelect = document.createElement('select')
      shapeSelect.className = 'input'
      shapeRow.appendChild(shapeSelect)
      const shapeOptions = ['Smooth', 'Polyline', 'Polyline Round']
      shapeOptions.forEach((option, index) => {
        const op = document.createElement('option')
        op.value = option
        op.text = option
        shapeSelect.appendChild(op)
      })
      if (item === 'canvas') {
        detailPanelTitle.innerHTML = 'Canvas'
        if (propertyContainer.children.length) {
          propertyContainer.innerHTML = ''
        }
      } else {
        if (item.getType() === 'node') {
          const { label } = item.getModel()
          detailPanelTitle.innerHTML = 'Node'
          propertyContainer.innerHTML = ''
          propertyContainer.appendChild(labelRow)
          labelInput.value = label
          updateItem(labelInput, 'label', item)
        }
        if (item.getType() === 'edge') {
          let { label, type, style } = item.getModel()
          if (!label) {
            label = ''
          }
          labelInput.value = label
          let shape
          if (type === 'cubic') {
            shape = 'Smooth'
          }
          if (type === 'polyline') {
            shape = 'Polyline'
            if (style.radius > 0) {
              shape = 'Polyline Round'
            }
          }
          shapeSelect.value = shape
          propertyContainer.innerHTML = ''
          detailPanelTitle.innerHTML = 'Edge'
          propertyContainer.appendChild(labelRow)
          propertyContainer.appendChild(shapeRow)
          updateItem(labelInput, 'label', item)
          updateItem(shapeSelect, 'shape', item)
        }
      }
    }
    function showMenu(name, x, y) {
      let menuDom
      if (name === 'canvas') {
        menuDom = `
          <ul class="context-menu" data-status="canvas-selected">
            <li class="menu" data-command="undo"><span role="img"><svg id="icon-undo" viewBox="0 0 1024 1024"><path d="M143.14 449.19q69.07-89.09 170.67-140.64Q415.41 257 537.52 256q183.18 4 315.81 114.11T1024 654.39q-58.06-107.11-161.66-170.17-103.6-63.06-232.73-65.06-107.1 1-196.69 45.54-89.58 44.55-152.65 121.62L407.4 713.45q7 7 7 17.01 0 10.01-7 17.02t-17.01 7.01H32.04q-14.01 0-23.02-9.01T0.01 722.46V364.11q0-10.01 7-17.02t17.02-7.01q10.01 0 17.02 7.01l102.1 102.1z"></path></svg></span><span>Undo</span></li>
            <li class="menu" data-command="redo"><span role="img"><svg id="icon-redo" viewBox="0 0 1024 1024"><path d="M999.98 340.08q-10.01 0-17.02 7.01l-102.1 102.1q-69.07-89.09-170.67-140.64Q608.59 257 487.48 256q-184.18 4-316.81 114.11T0 654.39q58.06-107.11 161.66-170.17 103.6-63.06 232.73-65.06 107.1 1 197.19 45.54 90.09 44.55 152.15 121.62L616.6 713.45q-7 7-7 17.01 0 10.01 7 17.02t17.01 7.01h358.35q14.01 0 23.02-9.01t9.01-23.02V364.11q0-10.01-7-17.02t-17.01-7.01z"></path></svg></span><span>Redo</span></li>
            <li class="menu" data-command="pasteHere"><span role="img"><svg id="icon-paste" viewBox="0 0 1024 1024"><path d="M795.99 199.33h-75.02v-62.16h109.31q10.72 0 19.3 8.58 8.57 8.57 8.57 19.29v102.88h-62.16v-68.59zM240.87 898.05h-75.02V199.33h75.02v-62.16H131.56q-10.72 0-19.29 8.58-8.57 8.57-8.57 19.29v760.88q0 10.71 8.57 18.75t19.29 9.11h102.88l6.43-55.73z m411.52-623.7H309.46V137.17h68.58V62.16q1.07-26.8 18.22-43.94Q413.41 1.08 440.2 0.01h75.01q26.8 1.07 43.94 18.21 17.14 17.14 18.22 43.94v75.01h75.02v137.18zM515.21 62.16H440.2v75.01h75.01V62.16z m405.09 938.77V548.69L720.97 342.93H343.75q-16.08 0-25.19 8.57-9.11 8.57-9.11 19.3v623.7q0 10.72 8.57 18.76 8.57 8.04 19.29 9.11H886q15 4.28 24.11-2.68 9.11-6.97 10.18-18.76z m-68.58-438.31H714.54v-151.1l137.18 151.1z m6.43 411.52H371.61V411.52h280.78v212.19h205.76v350.43z"></path></svg></span><span>Paste Here</span></li>
          </ul>
        `
      }
      if (name === 'node') {
        menuDom = `
          <ul class="context-menu" data-status="canvas-selected">
            <li class="menu" data-command="copy"><span role="img"><svg id="icon-copy" viewBox="0 0 1024 1024"><path d="M990.08 1017.64h-549.1q-10.6 0-18.55-8.48-7.95-8.48-9.01-19.08V373.13q1.06-10.6 10.07-18.55 9.01-7.95 23.85-9.01h373.13L1024 549.1v448.4q-5.3 5.3-14.31 12.19-9.01 6.89-19.61 7.95zM814.11 407.06v135.68H949.8L814.11 407.06zM949.8 610.58H746.27V407.06H474.9V949.8h474.9V610.58z m-610.59 67.85H67.84V67.84h271.37v203.53h271.37v-67.84L407.06 0H33.92Q18.02 0 9.01 8.48T0 27.56v684.79q0 10.6 8.48 18.55 8.48 7.95 19.08 9.01h311.65v-61.48z m67.85-610.59l135.68 135.69H407.06V67.84z"></path></svg></span><span>Copy</span></li>
            <li class="menu" data-command="delete"><span role="img"><svg id="icon-delete" viewBox="0 0 1024 1024"><path d="M828.55 311.65q-17.81 0-30.05 11.13-12.25 11.13-14.47 28.94l-52.32 529.81h-95.72l16.7-461.91q0-14.47-10.02-25.05-10.02-10.57-25.05-11.13-15.02-0.56-25.6 8.91-10.58 9.46-10.58 25.04l-16.69 464.14H459.01l-15.58-465.25q-1.12-15.58-11.69-25.04-10.57-9.47-25.6-8.91-15.03 0.56-24.49 11.13-9.46 10.57-9.46 25.04l15.58 463.03h-94.6l-52.32-529.81q-2.22-17.81-14.47-28.94-12.24-11.13-30.05-11.13h-3.34q-15.58 2.23-25.04 13.36-9.46 11.13-8.35 26.71l60.1 599.93q3.34 31.17 25.6 51.21 22.26 20.03 53.43 21.14h426.3q31.16-1.11 53.42-21.14t26.72-51.21l58.99-603.27q0-15.58-10.57-26.15-10.58-10.58-25.05-10.58z m107.96-71.23l-7.79-61.22q-5.56-35.62-31.72-57.88-26.15-22.26-61.77-23.37h-170.3l-3.34-32.28q-2.22-28.94-22.25-46.75Q619.3 1.11 590.36 0H433.42Q404.48 1.11 385 18.92q-19.48 17.81-22.82 46.75l-2.22 32.28H188.55q-35.62 1.11-61.22 23.37T96.17 179.2l-8.91 63.44q0 7.79 5.01 12.8 5.01 5.01 12.8 5.01h816.98q6.67-1.11 11.13-6.68 4.46-5.56 3.34-13.35zM422.29 97.95l2.22-27.83q1.12-6.68 8.91-7.79h158.05q6.68 1.11 8.91 7.79l1.11 27.83h-179.2z"></path></svg></span><span>Delete</span></li>
          </ul>
        `
      }
      if (name === 'edge') {
        menuDom = `
          <ul class="context-menu" data-status="canvas-selected">
            <li class="menu" data-command="delete"><span role="img"><svg id="icon-delete" viewBox="0 0 1024 1024"><path d="M828.55 311.65q-17.81 0-30.05 11.13-12.25 11.13-14.47 28.94l-52.32 529.81h-95.72l16.7-461.91q0-14.47-10.02-25.05-10.02-10.57-25.05-11.13-15.02-0.56-25.6 8.91-10.58 9.46-10.58 25.04l-16.69 464.14H459.01l-15.58-465.25q-1.12-15.58-11.69-25.04-10.57-9.47-25.6-8.91-15.03 0.56-24.49 11.13-9.46 10.57-9.46 25.04l15.58 463.03h-94.6l-52.32-529.81q-2.22-17.81-14.47-28.94-12.24-11.13-30.05-11.13h-3.34q-15.58 2.23-25.04 13.36-9.46 11.13-8.35 26.71l60.1 599.93q3.34 31.17 25.6 51.21 22.26 20.03 53.43 21.14h426.3q31.16-1.11 53.42-21.14t26.72-51.21l58.99-603.27q0-15.58-10.57-26.15-10.58-10.58-25.05-10.58z m107.96-71.23l-7.79-61.22q-5.56-35.62-31.72-57.88-26.15-22.26-61.77-23.37h-170.3l-3.34-32.28q-2.22-28.94-22.25-46.75Q619.3 1.11 590.36 0H433.42Q404.48 1.11 385 18.92q-19.48 17.81-22.82 46.75l-2.22 32.28H188.55q-35.62 1.11-61.22 23.37T96.17 179.2l-8.91 63.44q0 7.79 5.01 12.8 5.01 5.01 12.8 5.01h816.98q6.67-1.11 11.13-6.68 4.46-5.56 3.34-13.35zM422.29 97.95l2.22-27.83q1.12-6.68 8.91-7.79h158.05q6.68 1.11 8.91 7.79l1.11 27.83h-179.2z"></path></svg></span><span>Delete</span></li>
          </ul>
        `
      }
      menuContainer.innerHTML = menuDom
      menuContainer.setAttribute('style', `position:absolute;left:${x + 6}px;top:${y + 6}px`)
    }
    let clipboard
    function copy(node) {
      clipboard = node
      menuContainer.setAttribute('style', `display:none`)
    }
    /**
    * edge 的粘贴没有实际意义，只需考虑 node
    */
    function paste(x, y) {
      const timestamp = new Date().getTime()
      const id = `line-${timestamp}`
      const model = clipboard.getModel()
      console.log(model)
      model.id = id
      model.x = x + parseInt(model.width / 2)
      model.y = y + parseInt(model.height / 2)
      graph.addItem('node', model, true)
      menuContainer.setAttribute('style', `display:none`)
    }
    function isType(value, type) {
      const toString = {}.toString
      return toString.call(value) === '[object ' + type + ']'
    }
    function isArray(value) {
      return Array.isArray ?
        Array.isArray(value) :
        isType(value, 'Array')
    }
    function clone(obj) {
      if (typeof obj !== 'object' || obj === null) {
        return obj
      }
      let rst
      if (isArray(obj)) {
        rst = []
        for (let i = 0, l = obj.length; i < l; i++) {
          if (typeof obj[i] === 'object' && obj[i] != null) {
            rst[i] = clone(obj[i])
          } else {
            rst[i] = obj[i]
          }
        }
      } else {
        rst = {}
        for (const k in obj) {
          if (typeof obj[k] === 'object' && obj[k] != null) {
            rst[k] = clone(obj[k])
          } else {
            rst[k] = obj[k]
          }
        }
      }
      return rst
    }

    const graph = new G6.Graph({
      container: canvas,
      width: container.clientWidth - 480,
      height: container.clientHeight,
      modes: {
        default: [
          {
            type: 'drag-canvas'
          }
        ],
        edit: [
          'drag-canvas',
          'dragPanelItemAddNode',
          'dragNode',
          'dragCanvasCursor',
          'hoverAnchorActived',
          'hoverNodeActived',
          'clickSelected',
          'dragPoint',
          'hoverEdgeActived',
          'deleteItem',
          'contextMenu'
        ]
      },
      plugins: [minimap],
      enabledStack: true
    })

    graph.setMode('edit')
    graph.render()
    graph.on('stackchange', e => {
      const undoStack = graph.getUndoStack()
      const redoStack = graph.getRedoStack()
      const undoMenu = document.querySelector('li[data-command="undo"]')
      const redoMenu = document.querySelector('li[data-command="redo"]')
      if (undoStack.length === 1) {
        if (undoMenu) {
          undoMenu.classList.add('disabled')
          undoMenu.setAttribute('style', 'cursor: not-allowed')
        }
      } else {
        if (undoMenu) {
          undoMenu.classList.remove('disabled')
          undoMenu.removeAttribute('style')
        }
      }
      if (redoStack.length === 0) {
        if (redoMenu) {
          redoMenu.classList.add('disabled')
          redoMenu.setAttribute('style', 'cursor: not-allowed')
        }
      } else {
        if (redoMenu) {
          redoMenu.classList.remove('disabled')
          redoMenu.removeAttribute('style')
        }
      }
    })
  </script>
</body>

</html>